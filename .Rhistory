DataTemp <- data[c("Year", "Education", "Age", "Income")] # Dataset without ID column.
miceImp <- mice(DataTemp, method = method, m = m, maxit = maxit) # Perform MICE imputation
# Readd the ID column
CompleteDataset <- lapply(1:m, function(i) {
CompleteData <- complete(miceImp, action = i)
CompleteData <- cbind(ID = ID, CompleteData)
return(CompleteData)
})
return(CompleteDataset)  # Return a list of completed datasets
}
# Apply imputation
mice_bal_mcar_50 <- Data_Imputation_mice(balanced_panel_data_mcar_50)
mice_bal_mcar_30 <- Data_Imputation_mice(balanced_panel_data_mcar_30)
mice_bal_mcar_10 <- Data_Imputation_mice(balanced_panel_data_mcar_10)
mice_bal_mar_50 <- Data_Imputation_mice(balanced_panel_data_mar_50)
mice_bal_mar_30 <- Data_Imputation_mice(balanced_panel_data_mar_30)
mice_bal_mar_10 <- Data_Imputation_mice(balanced_panel_data_mar_10)
mice_bal_mnar_50 <- Data_Imputation_mice(balanced_panel_data_mnar_50)
mice_bal_mnar_30 <- Data_Imputation_mice(balanced_panel_data_mnar_30)
mice_bal_mnar_10 <- Data_Imputation_mice(balanced_panel_data_mnar_10)
mice_unbal_mcar_50 <- Data_Imputation_mice(unbalanced_panel_data_mcar_50)
mice_unbal_mcar_30 <- Data_Imputation_mice(unbalanced_panel_data_mcar_30)
mice_unbal_mcar_10 <- Data_Imputation_mice(unbalanced_panel_data_mcar_10)
mice_unbal_mar_50 <- Data_Imputation_mice(unbalanced_panel_data_mar_50)
mice_unbal_mar_30 <- Data_Imputation_mice(unbalanced_panel_data_mar_30)
mice_unbal_mar_10 <- Data_Imputation_mice(unbalanced_panel_data_mar_10)
mice_unbal_mnar_50 <- Data_Imputation_mice(unbalanced_panel_data_mnar_50)
mice_unbal_mnar_30 <- Data_Imputation_mice(unbalanced_panel_data_mnar_30)
mice_unbal_mnar_10 <- Data_Imputation_mice(unbalanced_panel_data_mnar_10)
EndTime_mice <- Sys.time()  # Ending time
ExecutionTime_mice <- EndTime_mice - StartTime_mice
print(ExecutionTime_mice) # Time difference of 1.326622 mins
######################
## mitml package
######################
packageVersion("mitml")
## Imputation ##
## Balanced Panel##
StartTime_mitml <- Sys.time()  # Starting time
pdata_bal <- pdata.frame(balanced_panel_data, index = c("ID", "Year")) # Convert the data frame to a panel data frame
# Estimate the models
FE_Model <- plm(Income ~ Year + Education + Age, data = pdata_bal, model = "within")
RE_Model <- plm(Income ~ Year + Education + Age, data = pdata_bal, model = "random")
HausmanTest <- phtest(FE_Model, RE_Model) # Perform the Hausman test to compare the fixed and random effects models
print(HausmanTest)
# p-value is 0.2185, which is > 0.05. S0 the null hypothesis cannot be rejected.
# This implies that the random effects in Education and Age is more appropriate.
# Function to impute data
Data_Imputation_mitml_Bal <- function(panel_data) {
SelectedData <- panel_data[c("ID", "Year", "Education", "Age", "Income")]
# Define the type vector and assign column names
type <- c(0, -2, 3, 3, 1)
names(type) <- colnames(SelectedData)
ImputedData <- panImpute(SelectedData, type = type, n.burn = 1000, n.iter = 100, m = 3)   # Impute missing data
ImputedList <- mitmlComplete(ImputedData, print = "all")
return(ImputedList)
}
# Apply the function to each dataset
mitml_bal_mcar_50 <- Data_Imputation_mitml_Bal(balanced_panel_data_mcar_50)
mitml_bal_mcar_30 <- Data_Imputation_mitml_Bal(balanced_panel_data_mcar_30)
mitml_bal_mcar_10 <- Data_Imputation_mitml_Bal(balanced_panel_data_mcar_10)
mitml_bal_mar_50 <- Data_Imputation_mitml_Bal(balanced_panel_data_mar_50)
mitml_bal_mar_30 <- Data_Imputation_mitml_Bal(balanced_panel_data_mar_30)
mitml_bal_mar_10 <- Data_Imputation_mitml_Bal(balanced_panel_data_mar_10)
mitml_bal_mnar_50 <- Data_Imputation_mitml_Bal(balanced_panel_data_mnar_50)
mitml_bal_mnar_30 <- Data_Imputation_mitml_Bal(balanced_panel_data_mnar_30)
mitml_bal_mnar_10 <- Data_Imputation_mitml_Bal(balanced_panel_data_mnar_10)
## Unbalanced ##
pdata_unbal <- pdata.frame(unbalanced_panel_data, index = c("ID", "Year")) # Convert the data frame to a panel data frame
# Estimate the models
FE_Model <- plm(Income ~ Year + Education + Age, data = pdata_unbal, model = "within")
RE_Model <- plm(Income ~ Year + Education + Age, data = pdata_unbal, model = "random")
HausmanTest <- phtest(FE_Model, RE_Model) # Perform the Hausman test to compare the fixed and random effects models
print(HausmanTest)
# p-value is 2.2e-16, which is < 0.05. So null hypothesis can be rejected.
# implying that the fixed effects in Education and Age is more appropriate.
# Function to impute data for unbalanced panels
Data_Imputation_mitml_Unbal <- function(panel_data) {
# Prepare the data by ungrouping and selecting relevant columns
panel_data <- panel_data %>%
ungroup()
SelectedData <- as.data.frame(panel_data[c("ID", "Year", "Education", "Age", "Income")])
# Define the type vector and assign column names
type <- c(0, -2, 2, 2, 1)
names(type) <- colnames(SelectedData)
ImputedData <- panImpute(SelectedData, type = type, n.burn = 1000, n.iter = 100, m = 3)   # Impute missing data
ImputedList <- mitmlComplete(ImputedData, print = "all")   # Extract imputed datasets
return(ImputedList)
}
# Apply the function to each dataset
mitml_unbal_mcar_50 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mcar_50)
mitml_unbal_mcar_30 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mcar_30)
mitml_unbal_mcar_10 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mcar_10)
mitml_unbal_mar_50 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mar_50)
mitml_unbal_mar_30 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mar_30)
mitml_unbal_mar_10 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mar_10)
mitml_unbal_mnar_50 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mnar_50)
mitml_unbal_mnar_30 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mnar_30)
mitml_unbal_mnar_10 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mnar_10)
EndTime_mitml <- Sys.time()  # Ending time
ExecutionTime_mitml <- EndTime_mitml - StartTime_mitml
print(ExecutionTime_mitml) # Time difference of 52.44876 secs
############################
## Amelia package
############################
packageVersion("Amelia")
StartTime_amelia <- Sys.time()  # Starting time
# Function to impute data
Data_Imputation_Amelia <- function(data) {
# Convert the data to panel data using plm package
pdata <- pdata.frame(data, index = c("ID", "Year"))
pdata = pdata[c("ID", "Year", "Education", "Age", "Income")]
pdata$Year <- as.numeric(as.character(pdata$Year))
# Perform the imputation using Amelia
ImputedData <- amelia(
pdata,
m = 3,
ts = "Year",
cs = "ID",
noms = "Education"
)
return(ImputedData)
}
# Apply the function to each dataset and store results
amelia_bal_mcar_50 <- Data_Imputation_Amelia(balanced_panel_data_mcar_50)
amelia_bal_mcar_30 <- Data_Imputation_Amelia(balanced_panel_data_mcar_30)
amelia_bal_mcar_10 <- Data_Imputation_Amelia(balanced_panel_data_mcar_10)
amelia_bal_mar_50 <- Data_Imputation_Amelia(balanced_panel_data_mar_50)
amelia_bal_mar_30 <- Data_Imputation_Amelia(balanced_panel_data_mar_30)
amelia_bal_mar_10 <- Data_Imputation_Amelia(balanced_panel_data_mar_10)
amelia_bal_mnar_50 <- Data_Imputation_Amelia(balanced_panel_data_mnar_50)
amelia_bal_mnar_30 <- Data_Imputation_Amelia(balanced_panel_data_mnar_30)
amelia_bal_mnar_10 <- Data_Imputation_Amelia(balanced_panel_data_mnar_10)
amelia_unbal_mcar_50 <- Data_Imputation_Amelia(unbalanced_panel_data_mcar_50)
amelia_unbal_mcar_30 <- Data_Imputation_Amelia(unbalanced_panel_data_mcar_30)
amelia_unbal_mcar_10 <- Data_Imputation_Amelia(unbalanced_panel_data_mcar_10)
amelia_unbal_mar_50 <- Data_Imputation_Amelia(unbalanced_panel_data_mar_50)
amelia_unbal_mar_30 <- Data_Imputation_Amelia(unbalanced_panel_data_mar_30)
amelia_unbal_mar_10 <- Data_Imputation_Amelia(unbalanced_panel_data_mar_10)
amelia_unbal_mnar_50 <- Data_Imputation_Amelia(unbalanced_panel_data_mnar_50)
amelia_unbal_mnar_30 <- Data_Imputation_Amelia(unbalanced_panel_data_mnar_30)
amelia_unbal_mnar_10 <- Data_Imputation_Amelia(unbalanced_panel_data_mnar_10)
EndTime_amelia <- Sys.time()  # Ending time
ExecutionTime_amelia <- EndTime_amelia - StartTime_amelia
print(ExecutionTime_amelia) # Time difference of 51.04909 secs
## Balanced Panel
## Balanced Panel with Random Effect Model for mitml
mitml_Coff_bal <- function(mitml_imp) {
CoList <- list() # Empty list to store the coefficients from individual datasets
for (i in 1:length(mitml_imp)) {
pdata <- pdata.frame(mitml_imp[[i]], index = c("ID", "Year")) # Convert to panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Apply Rubin's Rules to generate the pooled coefficients
CoefficientsList <- do.call(rbind, CoList)
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE)
CoDf <- data.frame(
Term = names(PooledCoefficient),
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_mitml_bal_mcar_50 <- mitml_Coff_bal(mitml_bal_mcar_50)
analyze_mitml_bal_mcar_50
## Balanced Panel
mitml_Coff_bal <- function(mitml_imp) {
CoList <- list() # Empty list to store the coefficients from individual dataset
for (i in 1:length(mitml_imp)) {
pdata <- pdata.frame(mitml_imp[[i]], index = c("ID", "Year")) # Convert into panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Apply Rubin's Rules to generate the pooled coefficients
CoefficientsList <- do.call(rbind, CoList)
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE)
CoDf <- data.frame(
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_mitml_bal_mcar_50 <- mitml_Coff_bal(mitml_bal_mcar_50)
analyze_mitml_bal_mcar_50
## Unbalanced Panel
mitml_Coff_unbal <- function(mitml_imp) {
CoList <- list() # Empty list to store the coefficients from individual dataset
for (i in 1:length(mitml_imp)) {
pdata <- pdata.frame(mitml_imp[[i]], index = c("ID", "Year")) # Convert into panel data format
FixedEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
CoList[[i]] <- coef(FixedEffectModel) # Extract coefficients
}
# Apply Rubin's Rules to generate the pooled coefficients
CoefficientsList <- do.call(rbind, CoList)
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE)
CoDf <- data.frame(
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the analysis function to each set of imputed datasets
analyze_mitml_unbal_mcar_50 <- mitml_Coff_unbal(mitml_unbal_mcar_50)
analyze_mitml_unbal_mcar_50
# Apply the analysis function to each set of imputed datasets
analyze_mitml_unbal_mcar_50 <- mitml_Coff_unbal(mitml_unbal_mcar_50)
analyze_mitml_unbal_mcar_30 <- mitml_Coff_unbal(mitml_unbal_mcar_30)
analyze_mitml_unbal_mcar_10 <- mitml_Coff_unbal(mitml_unbal_mcar_10)
analyze_mitml_unbal_mar_50 <- mitml_Coff_unbal(mitml_unbal_mar_50)
analyze_mitml_unbal_mar_30 <- mitml_Coff_unbal(mitml_unbal_mar_30)
analyze_mitml_unbal_mar_10 <- mitml_Coff_unbal(mitml_unbal_mar_10)
analyze_mitml_unbal_mnar_50 <- mitml_Coff_unbal(mitml_unbal_mnar_50)
analyze_mitml_unbal_mnar_30 <- mitml_Coff_unbal(mitml_unbal_mnar_30)
analyze_mitml_unbal_mnar_10 <- mitml_Coff_unbal(mitml_unbal_mnar_10)
### amelia ###
## Analyze Amelia Imputed Data with Random Effect Model
Analyze_Amelia <- function(imputed_list) {
CoList <- list() # Empty list to store coefficients from each imputed dataset
# Apply the random effects model and extract coefficients
for (i in 1:length(imputed_list)) {
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year")) # Convert to panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Pool the coefficients across imputations
CoefficientsList <- do.call(rbind, CoList) # Combine coefficients
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE) # Average across imputations
# Create a data frame of the pooled coefficients
CoDf <- data.frame(
Term = names(PooledCoefficient),
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- Analyze_Amelia(balanced_panel_data_mcar_50)
### amelia ###
Analyze_Amelia <- function(imputed_list) {
CoList <- list() # Empty list to store coefficients from each imputed dataset
# Apply the random effects model and extract coefficients
for (i in 1:length(imputed_list)) {
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year")) # Convert to panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Pool the coefficients across imputations
CoefficientsList <- do.call(rbind, CoList) # Combine coefficients
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE) # Average across imputations
# Create a data frame of the pooled coefficients
CoDf <- data.frame(
Term = names(PooledCoefficient),
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- Analyze_Amelia(amelia_bal_mcar_50)
amelia_bal_mcar_50
### amelia ###
Analyze_Amelia <- function(imputed_list) {
CoList <- list() # Empty list to store coefficients from each imputed dataset
# Apply the random effects model and extract coefficients
for (i in 1:length(imputed_list)) {
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year")) # Convert to panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Pool the coefficients across imputations
CoefficientsList <- do.call(rbind, CoList) # Combine coefficients
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE) # Average across imputations
# Create a data frame of the pooled coefficients
CoDf <- data.frame(
Term = names(PooledCoefficient),
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- Analyze_Amelia(amelia_bal_mcar_50)
amelia_bal_mcar_50
### amelia ###
Analyze_Amelia <- function(imputed_list) {
CoList <- list() # Empty list to store coefficients from each imputed dataset
# Apply the random effects model and extract coefficients
for (i in 1:length(imputed_list)) {
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year")) # Convert to panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Pool the coefficients across imputations
CoefficientsList <- do.call(rbind, CoList) # Combine coefficients
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE) # Average across imputations
# Create a data frame of the pooled coefficients
CoDf <- data.frame(
Term = names(PooledCoefficient),
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- Analyze_Amelia(amelia_bal_mcar_50)
### amelia ###
Analyze_Amelia <- function(imputed_list) {
CoList <- lapply(1:length(imputed_list), function(i) {
# Convert to panel data format for each imputed dataset
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year"))
# Apply the random effects model and extract coefficients
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
coef(RandomEffectModel) # Extract coefficients
})
# Pool the coefficients across imputations
CoefficientsList <- do.call(rbind, CoList) # Combine coefficients into a matrix
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE) # Average across imputations
# Create a data frame of the pooled coefficients
CoDf <- data.frame(
Term = names(PooledCoefficient),
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- Analyze_Amelia(amelia_bal_mcar_50)
### amelia ###
amelia_Coff_bal <- function(amelia_imp) {
CoList <- list() # Empty list to store the coefficients from individual dataset
for (i in 1:length(amelia_imp)) {
pdata <- pdata.frame(amelia_imp[[i]], index = c("ID", "Year")) # Convert into panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Apply Rubin's Rules to generate the pooled coefficients
CoefficientsList <- do.call(rbind, CoList)
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE)
CoDf <- data.frame(
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- amelia_Coff_bal(amelia_bal_mcar_50)
### amelia ###
amelia_Coff_bal <- function(amelia_imp) {
CoList <- list() # Empty list to store the coefficients from individual dataset
amelia_imp <- amelia_imp$imputations
for (i in 1:length(amelia_imp)) {
pdata <- pdata.frame(amelia_imp[[i]], index = c("ID", "Year")) # Convert into panel data format
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
CoList[[i]] <- coef(RandomEffectModel) # Extract coefficients
}
# Apply Rubin's Rules to generate the pooled coefficients
CoefficientsList <- do.call(rbind, CoList)
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE)
CoDf <- data.frame(
Coefficient = PooledCoefficient
)
return(CoDf)
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- amelia_Coff_bal(amelia_bal_mcar_50)
analyze_amelia_bal_mcar_50
return(CoDf)
### Unbalanced Panel
amelia_Coff_unbal <- function(amelia_imp) {
CoList <- list() # Empty list to store the coefficients from individual dataset
amelia_imp <- amelia_imp$imputations
for (i in 1:length(amelia_imp)) {
pdata <- pdata.frame(amelia_imp[[i]], index = c("ID", "Year")) # Convert into panel data format
FixedEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
CoList[[i]] <- coef(FixedEffectModel) # Extract coefficients
}
# Apply Rubin's Rules to generate the pooled coefficients
CoefficientsList <- do.call(rbind, CoList)
PooledCoefficient <- colMeans(CoefficientsList, na.rm = TRUE)
CoDf <- data.frame(
Coefficient = PooledCoefficient
)
return(CoDf)
}
analyze_amelia_unbal_mcar_50 <- amelia_Coff_unbal(amelia_unbal_mcar_50)
analyze_amelia_unbal_mcar_50
analyze_amelia_unbal_mcar_50 <- amelia_Coff_unbal(amelia_unbal_mcar_50)
analyze_amelia_unbal_mcar_30 <- amelia_Coff_unbal(amelia_unbal_mcar_30)
analyze_amelia_unbal_mcar_10 <- amelia_Coff_unbal(amelia_unbal_mcar_10)
analyze_amelia_unbal_mar_50 <- amelia_Coff_unbal(amelia_unbal_mar_50)
analyze_amelia_unbal_mar_30 <- amelia_Coff_unbal(amelia_unbal_mar_30)
analyze_amelia_unbal_mar_10 <- amelia_Coff_unbal(amelia_unbal_mar_10)
analyze_amelia_unbal_mnar_50 <- amelia_Coff_unbal(amelia_unbal_mnar_50)
analyze_amelia_unbal_mnar_30 <- amelia_Coff_unbal(amelia_unbal_mnar_30)
analyze_amelia_unbal_mnar_10 <- amelia_Coff_unbal(amelia_unbal_mnar_10)
############################
## LSTM Network
############################
packageVersion("keras")
StartTime_LSTM <- Sys.time()  # Starting time
Data_Imputation_LSTM <- function(data) {
# Remove the rows of the cells that include missing values
MissingRows <- which(is.na(data$Income))
CompleteData <- data[!is.na(data$Income), ]
# Normalize Age and Income columns to train the LSTM model
AgeM <- mean(CompleteData$Age, na.rm = TRUE)
AgeSD <- sd(CompleteData$Age, na.rm = TRUE)
IncomeM <- mean(CompleteData$Income, na.rm = TRUE)
IncomeSD <- sd(CompleteData$Income, na.rm = TRUE)
CompleteData$Age <- (CompleteData$Age - AgeM) / AgeSD
CompleteData$Income <- (CompleteData$Income - IncomeM) / IncomeSD
# Convert categorical columns to numeric encoding
CompleteData <- CompleteData %>%
mutate(Year = as.numeric(factor(Year)),
Education = as.numeric(factor(Education)))
# Prepare data to train the model, excluding ID
TrainX <- as.matrix(CompleteData %>% select(Year, Education, Age))
TrainY <- CompleteData$Income
# Reshape the data into 3D to make LSTM calculation easier (samples, timesteps=1, features=3)
TrainX <- array(TrainX, dim = c(nrow(TrainX), 1, ncol(TrainX)))
# Build the model
model <- keras_model_sequential() %>%
layer_lstm(units = 50, input_shape = c(1, 3), return_sequences = FALSE) %>%
layer_dense(units = 1)
model %>% compile(
loss = 'mean_squared_error',
optimizer = optimizer_adam()
)
# Train the model
model %>% fit(TrainX, TrainY, epochs = 50, batch_size = 32, verbose = 1)
# Refill the missing values
MissingValues <- data[MissingRows, ]
MissingValues <- MissingValues %>%
mutate(Year = as.numeric(factor(Year)),
Education = as.numeric(factor(Education)),
Age = (Age - AgeM) / AgeSD)  # Normalize Age for missing data
XMissing <- as.matrix(MissingValues %>% select(Year, Education, Age))
XMissing <- array(XMissing, dim = c(nrow(XMissing), 1, ncol(XMissing)))
PredictedIncome <- model %>% predict(XMissing) # Predict the missing values
PredictedIncome <- PredictedIncome * IncomeSD + IncomeM # De-normalize the predicted income
data$Income[MissingRows] <- PredictedIncome # Fill the missing values
return(data)
}
# Apply the function to the dataset
lstm_bal_mcar_50 <- Data_Imputation_LSTM(balanced_panel_data_mcar_50)
lstm_bal_mcar_30 <- Data_Imputation_LSTM(balanced_panel_data_mcar_30)
lstm_bal_mcar_10 <- Data_Imputation_LSTM(balanced_panel_data_mcar_10)
lstm_bal_mar_50 <- Data_Imputation_LSTM(balanced_panel_data_mar_50)
lstm_bal_mar_30 <- Data_Imputation_LSTM(balanced_panel_data_mar_30)
lstm_bal_mar_10 <- Data_Imputation_LSTM(balanced_panel_data_mar_10)
lstm_bal_mnar_50 <- Data_Imputation_LSTM(balanced_panel_data_mnar_50)
lstm_bal_mnar_30 <- Data_Imputation_LSTM(balanced_panel_data_mnar_30)
lstm_bal_mnar_10 <- Data_Imputation_LSTM(balanced_panel_data_mnar_10)
lstm_unbal_mcar_50 <- Data_Imputation_LSTM(unbalanced_panel_data_mcar_50)
lstm_unbal_mcar_30 <- Data_Imputation_LSTM(unbalanced_panel_data_mcar_30)
lstm_unbal_mcar_10 <- Data_Imputation_LSTM(unbalanced_panel_data_mcar_10)
lstm_unbal_mar_50 <- Data_Imputation_LSTM(unbalanced_panel_data_mar_50)
lstm_unbal_mar_30 <- Data_Imputation_LSTM(unbalanced_panel_data_mar_30)
lstm_unbal_mar_10 <- Data_Imputation_LSTM(unbalanced_panel_data_mar_10)
lstm_unbal_mnar_50 <- Data_Imputation_LSTM(unbalanced_panel_data_mnar_50)
lstm_unbal_mnar_30 <- Data_Imputation_LSTM(unbalanced_panel_data_mnar_30)
lstm_unbal_mnar_10 <- Data_Imputation_LSTM(unbalanced_panel_data_mnar_10)
EndTime_LSTM <- Sys.time()  # Ending time
ExecutionTime_LSTM <- EndTime_LSTM - StartTime_LSTM
print(ExecutionTime_LSTM) # Time difference of 11.66831 mins
# Function to generate coefficients and intercepts
LSTM_Coff_bal <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year"))
FixedEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
Coefficients <- coef(FixedEffectModel) # Coefficients extraction
Coefficients <- as.data.frame(Coefficients)
return(Coefficients)
}
# Apply the function to each dataset and store results
analyze_lstm_bal_mcar_50 <- LSTM_Coff_bal(lstm_bal_mcar_50)
analyze_lstm_bal_mcar_50
return(Coefficients)
# Function to generate coefficients and intercepts
LSTM_Coff_bal <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year"))
RandomEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
Coefficients <- coef(RandomEffectModel) # Coefficients extraction
Coefficients <- as.data.frame(Coefficients)
return(Coefficients)
}
# Apply the function to each dataset and store results
analyze_lstm_bal_mcar_50 <- LSTM_Coff_bal(lstm_bal_mcar_50)
analyze_lstm_bal_mcar_50
# Apply the function to each dataset and store results
analyze_lstm_bal_mcar_50 <- LSTM_Coff_bal(lstm_bal_mcar_50)
analyze_lstm_bal_mcar_30 <- LSTM_Coff_bal(lstm_bal_mcar_30)
analyze_lstm_bal_mcar_10 <- LSTM_Coff_bal(lstm_bal_mcar_10)
analyze_lstm_bal_mar_50 <- LSTM_Coff_bal(lstm_bal_mar_50)
analyze_lstm_bal_mar_30 <- LSTM_Coff_bal(lstm_bal_mar_30)
analyze_lstm_bal_mar_10 <- LSTM_Coff_bal(lstm_bal_mar_10)
analyze_lstm_bal_mnar_50 <- LSTM_Coff_bal(lstm_bal_mnar_50)
analyze_lstm_bal_mnar_30 <- LSTM_Coff_bal(lstm_bal_mnar_30)
analyze_lstm_bal_mnar_10 <- LSTM_Coff_bal(lstm_bal_mnar_10)
LSTM_Coff_unbal <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year"))
FixedEffectModel <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
Coefficients <- coef(FixedEffectModel) # Coefficients extraction
Coefficients <- as.data.frame(Coefficients)
return(Coefficients)
}
analyze_lstm_unbal_mcar_50 <- LSTM_Coff_unbal(lstm_unbal_mcar_50)
analyze_lstm_unbal_mcar_50
analyze_lstm_unbal_mcar_50 <- LSTM_Coff_unbal(lstm_unbal_mcar_50)
analyze_lstm_unbal_mcar_30 <- LSTM_Coff_unbal(lstm_unbal_mcar_30)
analyze_lstm_unbal_mcar_10 <- LSTM_Coff_unbal(lstm_unbal_mcar_10)
analyze_lstm_unbal_mar_50 <- LSTM_Coff_unbal(lstm_unbal_mar_50)
analyze_lstm_unbal_mar_30 <- LSTM_Coff_unbal(lstm_unbal_mar_30)
analyze_lstm_unbal_mar_10 <- LSTM_Coff_unbal(lstm_unbal_mar_10)
analyze_lstm_unbal_mnar_50 <- LSTM_Coff_unbal(lstm_unbal_mnar_50)
analyze_lstm_unbal_mnar_30 <- LSTM_Coff_unbal(lstm_unbal_mnar_30)
analyze_lstm_unbal_mnar_10 <- LSTM_Coff_unbal(lstm_unbal_mnar_10)
analyze_lstm_bal_mcar_50
(80*2+40*1)/120
