# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
summary(data)
length(data$Education)
data$Education[is.na(df)] <- 7
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# 'Education' column - Highest general school degree
count(data, Education)
summary(data)
# MedianIncome
count(data, MedianIncome)
# MedianIncome
count(data, MedianIncome)
summary(data$MedianIncome)
# 'Year' column
count(data, Year)
# 'Year' column
count(data, Year)
summary(data$IndividualIncome)
330684
View(data)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
summary(data)
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
summary(data)
# 'ID' column
count(data, ID)
# 'Year' column
count(data, Year)
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# MedianIncome
count(data, MedianIncome)
summary(data$MedianIncome)
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
# Load necessary libraries
library(dplyr)
library(tidyr)
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# Fill missing values (if necessary, can be customized)
balanced_data <- balanced_data %>%
group_by(ID) %>%
mutate(
Education = zoo::na.locf(Education, na.rm = FALSE),
MedianIncome = zoo::na.locf(MedianIncome, na.rm = FALSE),
IndividualIncome = zoo::na.locf(IndividualIncome, na.rm = FALSE)
) %>%
ungroup()
# View the balanced panel data
print(balanced_data)
# View the balanced panel data
View(balanced_data)
# Step 1: Count the number of observations per ID
obs_per_id <- balanced_data %>%
group_by(ID) %>%
summarise(n_years = n_distinct(Year))
print(obs_per_id)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
merged_data <- complete_grid %>%
left_join(balanced_data, by = c("ID", "Year"))
# Find missing combinations
missing_combinations <- merged_data %>%
filter(is.na(Education) | is.na(MedianIncome) | is.na(IndividualIncome))
print(missing_combinations)
# Step 3: Verify if the panel is balanced
is_balanced <- n_distinct(obs_per_id$n_years) == 1 && nrow(missing_combinations) == 0
if (is_balanced) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
# Load necessary libraries
library(dplyr)
library(tidyr)
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# View the balanced panel data
View(balanced_data)
library(dplyr)
library(readxl)
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
summary(data)
# 'ID' column
count(data, ID)
# 'Year' column
count(data, Year)
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# MedianIncome
count(data, MedianIncome)
summary(data$MedianIncome)
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
# Load necessary libraries
library(dplyr)
library(tidyr)
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# View the balanced panel data
View(balanced_data)
# Step 1: Count the number of observations per ID
obs_per_id <- balanced_data %>%
group_by(ID) %>%
summarise(n_years = n_distinct(Year))
print(obs_per_id)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
merged_data <- complete_grid %>%
left_join(balanced_data, by = c("ID", "Year"))
# Find missing combinations
missing_combinations <- merged_data %>%
filter(is.na(Education) | is.na(MedianIncome) | is.na(IndividualIncome))
print(missing_combinations)
# Step 3: Verify if the panel is balanced
is_balanced <- n_distinct(obs_per_id$n_years) == 1 && nrow(missing_combinations) == 0
if (is_balanced) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
library(dplyr)
library(readxl)
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
summary(data)
# 'ID' column
count(data, ID)
# 'Year' column
count(data, Year)
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# MedianIncome
count(data, MedianIncome)
summary(data$MedianIncome)
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
summary(data$IndividualIncome)
summary(data)
View(data$IndividualIncome)
View(data)
# Load necessary libraries
library(dplyr)
library(tidyr)
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# Fill missing values (if necessary, can be customized)
balanced_data <- balanced_data %>%
group_by(ID) %>%
mutate(
Education = zoo::na.locf(Education, na.rm = FALSE),
MedianIncome = zoo::na.locf(MedianIncome, na.rm = FALSE),
IndividualIncome = zoo::na.locf(IndividualIncome, na.rm = FALSE)
) %>%
ungroup()
# View the balanced panel data
View(balanced_data)
# Step 1: Count the number of observations per ID
obs_per_id <- balanced_data %>%
group_by(ID) %>%
summarise(n_years = n_distinct(Year))
print(obs_per_id)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
merged_data <- complete_grid %>%
left_join(balanced_data, by = c("ID", "Year"))
# Find missing combinations
missing_combinations <- merged_data %>%
filter(is.na(Education) | is.na(MedianIncome) | is.na(IndividualIncome))
print(missing_combinations)
# Step 3: Verify if the panel is balanced
is_balanced <- n_distinct(obs_per_id$n_years) == 1 && nrow(missing_combinations) == 0
if (is_balanced) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
summary(data)
# 'ID' column
count(data, ID)
# 'Year' column
count(data, Year)
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# MedianIncome
count(data, MedianIncome)
summary(data$MedianIncome)
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
summary(data$IndividualIncome)
summary(data)
# Load necessary libraries
library(dplyr)
library(tidyr)
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# View the balanced panel data
print(balanced_data)
# Step 1: Count the number of observations per ID
obs_per_id <- balanced_data %>%
group_by(ID) %>%
summarise(n_years = n_distinct(Year))
print(obs_per_id)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
merged_data <- complete_grid %>%
left_join(balanced_data, by = c("ID", "Year"))
# Find missing combinations
missing_combinations <- merged_data %>%
filter(is.na(Education) | is.na(MedianIncome) | is.na(IndividualIncome))
print(missing_combinations)
# Step 3: Verify if the panel is balanced
is_balanced <- n_distinct(obs_per_id$n_years) == 1 && nrow(missing_combinations) == 0
if (is_balanced) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Check if the data is balanced panel or not
# Check the number of years for each ID
obs_per_id <- balanced_data %>%
group_by(ID) %>%
summarise(n_years = n_distinct(Year))
print(obs_per_id)
# Check if the data is balanced panel or not
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# Ensure equal number of years across IDs
obs_per_id <- balanced_data %>%
group_by(ID) %>%
summarise(n_years = n_distinct(Year))
print(obs_per_id)
# Check for duplicate ID-Year combinations
duplicates <- balanced_data %>%
group_by(ID, Year) %>%
filter(n() > 1)
print(duplicates)
# Check for any missing values in the entire dataframe
any_missing_values <- any(is.na(balanced_data))
if (any_missing_values) {
print("There are missing values in the data:")
missing_summary <- balanced_data %>%
summarise_all(~sum(is.na(.)))
print(missing_summary)
} else {
print("There are no missing values in the data.")
}
# Ensure the data is balanced
is_balanced <- all(n_distinct(obs_per_id$n_years) == 1) && nrow(duplicates) == 0 && !any_missing_values
if (is_balanced) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
total_na <- sum(is.na(data))
print(total_na)  # Total number of NA values in the data frame
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
total_na <- sum(is.na(data))
print(total_na)  # Total number of NA values in the data frame
library(dplyr)
library(readxl)
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "ind.median", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "MedianIncome", "IndividualIncome")
summary(data)
# 'ID' column
count(data, ID)
# 'Year' column
count(data, Year)
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# MedianIncome
count(data, MedianIncome)
summary(data$MedianIncome)
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
summary(data$IndividualIncome)
total_na <- sum(is.na(data))
print(total_na)  # Total number of NA values in the data frame
sum(is.na(data)) #Total number of NA values in the data frame
summary(data)
# Load necessary libraries
library(dplyr)
# Load necessary libraries
library(dplyr)
library(tidyr)
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# View the balanced panel data
print(balanced_data)
# View the balanced panel data
sum(is.na(balanced_data)) #Total number of NA values in the data frame
# View the balanced panel data
sum(is.na(balanced_data$ID)) #Total number of NA values in the data frame
# View the balanced panel data
sum(is.na(balanced_data$Year)) #Total number of NA values in the data frame
# View the balanced panel data
sum(is.na(balanced_data$Education)) #Total number of NA values in the data frame
sum(is.na(data$Education)) #Total number of NA values in the data frame
sum(is.na(data)) #Total number of NA values in the data frame
summary(data)
# Load necessary libraries
library(dplyr)
library(tidyr)
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# View the balanced panel data
sum(is.na(balanced_data$Education)) #Total number of NA values in the data frame
# Step 1: Determine the unique IDs and Years
unique_ids <- unique(data$ID)
unique_years <- unique(data$Year)
# Step 2: Create a data frame with all combinations of ID and Year
full_panel <- expand.grid(ID = unique_ids, Year = unique_years)
# Step 3: Merge the full panel with the original data
balanced_data <- full_panel %>%
left_join(data, by = c("ID", "Year"))
# View the balanced panel data
sum(is.na(balanced_data$Education)) #Total number of NA values in the data frame
# Step 1: Get the range of years for each ID
year_range <- data %>%
group_by(ID) %>%
summarize(Year_min = min(Year), Year_max = max(Year), .groups = 'drop')
# Step 2: Generate a complete panel of years for each ID
full_panel <- year_range %>%
rowwise() %>%
do(data.frame(ID = .$ID, Year = seq(.$Year_min, .$Year_max))) %>%
ungroup()
# Step 3: Merge the full panel with the original data
balanced_data <- full_panel %>%
left_join(data, by = c("ID", "Year"))
# View the balanced panel data
sum(is.na(balanced_data$Education)) #Total number of NA values in the data frame
# View the balanced panel data
sum(is.na(balanced_data$Education)) #Total number of NA values in the data frame
# Step 1: Get unique years for each ID from the original data
unique_years_per_id <- data %>%
group_by(ID) %>%
summarize(Years = list(sort(unique(Year))), .groups = 'drop')
# Step 2: Expand grid using years present in the data for each ID
full_panel <- unique_years_per_id %>%
ungroup() %>%
unnest(Years) %>%
group_by(ID) %>%
complete(Year = unique(Years)) %>%
ungroup()
# Step 3: Merge the expanded grid with the original data
balanced_data <- full_panel %>%
left_join(data, by = c("ID", "Year"))
# Step 3: Merge the expanded grid with the original data
balanced_data <- full_panel %>%
left_join(data, by = c("ID", "Year"))
# Step 1: Get unique years for each ID from the original data
unique_years_per_id <- data %>%
group_by(ID) %>%
summarize(Years = list(sort(unique(Year))), .groups = 'drop')
# Step 2: Expand grid using years present in the data for each ID
full_panel <- unique_years_per_id %>%
ungroup() %>%
unnest(Years) %>%
group_by(ID) %>%
complete(Year = unique(Years)) %>%
ungroup()
# Step 1: Create a complete set of ID and Year combinations
# Get unique IDs and Years
unique_ids <- unique(data$ID)
unique_years <- unique(data$Year)
# Generate all combinations
full_panel <- expand.grid(ID = unique_ids, Year = unique_years, stringsAsFactors = FALSE)
# Step 2: Merge this complete set with the original data
balanced_data <- full_panel %>%
left_join(data, by = c("ID", "Year"))
# Check if the data is balanced panel or not
# Identify all unique IDs and Years
all_ids <- unique(data$ID)
all_years <- unique(data$Year)
# Create a complete grid of all combinations of IDs and Years
complete_grid <- expand.grid(ID = all_ids, Year = all_years)
# Merge the grid with the original data
balanced_data <- complete_grid %>%
left_join(data, by = c("ID", "Year"))
# Ensure equal number of years across IDs
obs_per_id <- balanced_data %>%
group_by(ID) %>%
summarise(n_years = n_distinct(Year))
print(obs_per_id)
# Check for duplicate ID-Year combinations
duplicates <- balanced_data %>%
group_by(ID, Year) %>%
filter(n() > 1)
print(duplicates)
# Check for any missing values in the entire dataframe
any_missing_values <- any(is.na(balanced_data))
if (any_missing_values) {
print("There are missing values in the data:")
missing_summary <- balanced_data %>%
summarise_all(~sum(is.na(.)))
print(missing_summary)
} else {
print("There are no missing values in the data.")
}
# Ensure the data is balanced
is_balanced <- all(n_distinct(obs_per_id$n_years) == 1) && nrow(duplicates) == 0 && !any_missing_values
if (is_balanced) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
sum(is.na(data$Education)) #Total number of NA values in the data frame
sum(is.na(data) #Total number of NA values in the data frame
sum(is.na(data)) #Total number of NA values in the data frame
summary(data)
sum(is.na(data)) #Total number of NA values in the data frame
# 'Education' column - Highest general school degree
count(data, Education)
