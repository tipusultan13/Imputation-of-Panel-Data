balanced_panel_data_mnar_10$Income[mis_simulated_mnar_10] <- NA
summary(balanced_panel_data_mnar_10)
# Visualize the missing data pattern
aggr(balanced_panel_data_mnar_10,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(balanced_panel_data_mnar_10),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
########################
## Missingness in Unalanced Panel
########################
#### MCAR ####
##############
#### 50% ####
p_mis_50 <- 0.50
num_rows <- nrow(unbalanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_50 <- sample(1:num_rows, p_mis_50 * num_rows, replace = FALSE)
unbalanced_panel_data_mcar_50 <- unbalanced_panel_data
unbalanced_panel_data_mcar_50[mis_simulated_mcar_50, 5] <- NA
summary(unbalanced_panel_data_mcar_50)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mcar_50,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mcar_50),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### 30% ####
p_mis_30 <- 0.30
num_rows <- nrow(unbalanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_30 <- sample(1:num_rows, p_mis_30 * num_rows, replace = FALSE)
unbalanced_panel_data_mcar_30 <- unbalanced_panel_data
unbalanced_panel_data_mcar_30[mis_simulated_mcar_30, 5] <- NA
summary(unbalanced_panel_data_mcar_30)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mcar_30,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mcar_30),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### 10% ####
p_mis_10 <- 0.10
num_rows <- nrow(unbalanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_10 <- sample(1:num_rows, p_mis_10 * num_rows, replace = FALSE)
unbalanced_panel_data_mcar_10 <- unbalanced_panel_data
unbalanced_panel_data_mcar_10[mis_simulated_mcar_10, 5] <- NA
summary(unbalanced_panel_data_mcar_10)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mcar_10,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mcar_10),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### MAR ####
#############
#### 50% ####
unbalanced_panel_data_mar_50 <- unbalanced_panel_data
set.seed(123)
p_mis_50 <- 0.5  # 50% missingness
# Depending on Education, Age, and random error
mis_simulated_mar_50 <- 0.5 + 0.1 * unbalanced_panel_data_mar_50$Education +
0.2 * unbalanced_panel_data_mar_50$Age +
rnorm(nrow(unbalanced_panel_data_mar_50), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_50 <- mis_simulated_mar_50 < quantile(mis_simulated_mar_50, p_mis_50)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_50))
# Set values to NA in IndividualIncome where missingness occurs
unbalanced_panel_data_mar_50$Income[mis_simulated_mar_50] <- NA
# Summary of IndividualIncome after introducing missingness
summary(unbalanced_panel_data_mar_50)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mar_50,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mar_50),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### 30% ####
unbalanced_panel_data_mar_30 <- unbalanced_panel_data
set.seed(123)
p_mis_50 <- 0.3  # 30% missingness
# Depending on Education, Age, and random error
mis_simulated_mar_30 <- 0.7 + 0.1 * unbalanced_panel_data_mar_30$Education +
0.2 * unbalanced_panel_data_mar_30$Age +
rnorm(nrow(unbalanced_panel_data_mar_30), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_30 <- mis_simulated_mar_30 < quantile(mis_simulated_mar_30, p_mis_30)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_30))
# Set values to NA in IndividualIncome where missingness occurs
unbalanced_panel_data_mar_30$Income[mis_simulated_mar_30] <- NA
# Summary of IndividualIncome after introducing missingness
summary(unbalanced_panel_data_mar_30)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mar_30,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mar_30),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### 10% ####
unbalanced_panel_data_mar_10 <- unbalanced_panel_data
set.seed(123)
p_mis_50 <- 0.1  # 10% missingness
# Depending on Education, Age, and random error
mis_simulated_mar_10 <- 0.1 + 0.1 * unbalanced_panel_data_mar_10$Education +
0.2 * unbalanced_panel_data_mar_10$Age +
rnorm(nrow(unbalanced_panel_data_mar_10), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_10 <- mis_simulated_mar_10 < quantile(mis_simulated_mar_10, p_mis_10)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_10))
# Set values to NA in IndividualIncome where missingness occurs
unbalanced_panel_data_mar_10$Income[mis_simulated_mar_10] <- NA
# Summary of IndividualIncome after introducing missingness
summary(unbalanced_panel_data_mar_10)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mar_30,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mar_10),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### MNAR ####
##############
#### 50% ####
#### Probabilistic, Linear Regression model, Real data ####
p_mis_50 <- .50
unbalanced_panel_data_mnar_50 <- unbalanced_panel_data
# the missing of a value now also depends on IndividualIncome itself
mis_simulated_mnar_50 <- 0.5 + 0.1 * unbalanced_panel_data_mnar_50$Education +
0.2 * unbalanced_panel_data_mnar_50$Age +
0.5 * unbalanced_panel_data_mnar_50$Income + rnorm(nrow(unbalanced_panel_data), 0, 3)
mis_simulated_mnar_50 <- mis_simulated_mnar_50 < quantile(mis_simulated_mnar_50, p_mis_50)
unbalanced_panel_data_mnar_50$Income[mis_simulated_mnar_50] <- NA
summary(unbalanced_panel_data_mnar_50)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mnar_50,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mnar_50),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### 30% ####
p_mis_30 <- .30
unbalanced_panel_data_mnar_30 <- unbalanced_panel_data
# the missing of a value now also depends on IndividualIncome itself
mis_simulated_mnar_30 <-0.7 + 0.1 * unbalanced_panel_data_mnar_30$Education +
0.2 * unbalanced_panel_data_mnar_30$Age +
0.5 * unbalanced_panel_data_mnar_30$Income + rnorm(nrow(unbalanced_panel_data), 0, 3)
mis_simulated_mnar_30 <- mis_simulated_mnar_30 < quantile(mis_simulated_mnar_30, p_mis_30)
unbalanced_panel_data_mnar_30$Income[mis_simulated_mnar_30] <- NA
summary(unbalanced_panel_data_mnar_30)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mnar_30,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mnar_30),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
#### 10% ####
p_mis_10 <- .10
unbalanced_panel_data_mnar_10 <- unbalanced_panel_data
# the missing of a value now also depends on IndividualIncome itself
mis_simulated_mnar_10 <- 0.1 + 0.1 * unbalanced_panel_data_mnar_10$Education +
0.2 * unbalanced_panel_data_mnar_10$Age +
0.5 * unbalanced_panel_data_mnar_10$Income + rnorm(nrow(unbalanced_panel_data), 0, 3)
mis_simulated_mnar_10 <- mis_simulated_mnar_10 < quantile(mis_simulated_mnar_10, p_mis_10)
unbalanced_panel_data_mnar_10$Income[mis_simulated_mnar_10] <- NA
summary(unbalanced_panel_data_mnar_10)
# Visualize the missing data pattern
aggr(unbalanced_panel_data_mnar_10,
col = c('navyblue', 'red'),
numbers = TRUE,
sortVars = TRUE,
labels = names(unbalanced_panel_data_mnar_10),
cex.axis = .7,
gap = 3,
ylab = c("Missing data", "Pattern"))
###################
### Data Sets Overview and Formating
###################
## Format Vriable to Their Originl Format
convert_to_factors <- function(df) {
df$ID <- as.factor(df$ID)
df$Year <- as.factor(df$Year)
df$Education <- as.factor(df$Education)
return(df)
}
# Apply the function to each dataset
balanced_panel_data_mcar_50 <- convert_to_factors(balanced_panel_data_mcar_50)
balanced_panel_data_mcar_30 <- convert_to_factors(balanced_panel_data_mcar_30)
balanced_panel_data_mcar_10 <- convert_to_factors(balanced_panel_data_mcar_10)
balanced_panel_data_mar_50 <- convert_to_factors(balanced_panel_data_mar_50)
balanced_panel_data_mar_30 <- convert_to_factors(balanced_panel_data_mar_30)
balanced_panel_data_mar_10 <- convert_to_factors(balanced_panel_data_mar_10)
balanced_panel_data_mnar_50 <- convert_to_factors(balanced_panel_data_mnar_50)
balanced_panel_data_mnar_30 <- convert_to_factors(balanced_panel_data_mnar_30)
balanced_panel_data_mnar_10 <- convert_to_factors(balanced_panel_data_mnar_10)
unbalanced_panel_data_mcar_50 <- convert_to_factors(unbalanced_panel_data_mcar_50)
unbalanced_panel_data_mcar_30 <- convert_to_factors(unbalanced_panel_data_mcar_30)
unbalanced_panel_data_mcar_10 <- convert_to_factors(unbalanced_panel_data_mcar_10)
unbalanced_panel_data_mar_50 <- convert_to_factors(unbalanced_panel_data_mar_50)
unbalanced_panel_data_mar_30 <- convert_to_factors(unbalanced_panel_data_mar_30)
unbalanced_panel_data_mar_10 <- convert_to_factors(unbalanced_panel_data_mar_10)
unbalanced_panel_data_mnar_50 <- convert_to_factors(unbalanced_panel_data_mnar_50)
unbalanced_panel_data_mnar_30 <- convert_to_factors(unbalanced_panel_data_mnar_30)
unbalanced_panel_data_mnar_10 <- convert_to_factors(unbalanced_panel_data_mnar_10)
# balanced_panel_data_mcar_50
# balanced_panel_data_mcar_30
# balanced_panel_data_mcar_10
# balanced_panel_data_mar_50
# balanced_panel_data_mar_30
# balanced_panel_data_mar_10
# balanced_panel_data_mnar_50
# balanced_panel_data_mnar_30
# balanced_panel_data_mnar_10
# unbalanced_panel_data_mcar_50
# unbalanced_panel_data_mcar_30
# unbalanced_panel_data_mcar_10
# unbalanced_panel_data_mar_50
# unbalanced_panel_data_mar_30
# unbalanced_panel_data_mar_10
# unbalanced_panel_data_mnar_50
# unbalanced_panel_data_mnar_30
# unbalanced_panel_data_mnar_10
# Convert the data frame to a panel data frame
pdata_bal <- pdata.frame(balanced_panel_data, index = c("ID", "Year"))
# Estimate the fixed effects model
fe_model <- plm(Income ~ Year + Education + Age, data = pdata_bal, model = "within")
# Estimate the random effects model
re_model <- plm(Income ~ Year + Education + Age, data = pdata_bal, model = "random")
# Perform the Hausman test to compare the fixed and random effects models
hausman_test <- phtest(fe_model, re_model)
# Print the results of the Hausman test
print(hausman_test)
# Function to impute data
Data_Imputation_mitml_Bal <- function(panel_data) {
# Selecting relevant columns
selected_data <- panel_data[c("ID", "Year", "Education", "Age", "Income")]
# Define the type vector and assign column names
type <- c(0, -2, 3, 3, 1)
names(type) <- colnames(selected_data)
# Impute missing data
imputed_data <- panImpute(selected_data, type = type, n.burn = 1000, n.iter = 100, m = 3)
# Extract imputed datasets
imputed_list <- mitmlComplete(imputed_data, print = "all")
return(imputed_list)
}
# Apply the function to each dataset
mitml_bal_mcar_50 <- Data_Imputation_mitml_Bal(balanced_panel_data_mcar_50)
# Function to analyze imputed data and extract coefficients
Analyze_mitml_Bal <- function(imputed_list) {
# Step 2: Perform Breusch-Pagan test to check the panel effect
breusch_pagan_results <- lapply(imputed_list, function(x) {
pdata <- pdata.frame(x, index = c("ID", "Year"))
bp_test <- plmtest(plm(Income ~ Education + Age, data = pdata, model = "pooling"), type = "bp")
return(bp_test$p.value)
})
# Step 3: Based on Breusch-Pagan test, perform the appropriate regression
model_list <- lapply(1:length(imputed_list), function(i) {
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year"))
if (breusch_pagan_results[[i]] > 0.05) {
# No panel effect, proceed with Pooled OLS model
return(plm(Income ~ Year + Education + Age, data = pdata, model = "pooling"))
} else {
# Panel effect exists, proceed to Hausman test
random_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
fixed_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
# Perform Hausman test
hausman_test <- phtest(fixed_model, random_model)
if (hausman_test$p.value <= 0.05) {
# Use Fixed Effects model if correlation exists
print("Fixed Effect Model:")
return(fixed_model)
} else {
# Use Random Effect model if corellation does not exists
print("Random Effect Model:")
return(random_model)
}
}
})
# Step 4: Pool the results
pooled_results <- testEstimates(model_list)
# Return the pooled results summary
return(summary(pooled_results))
}
# Apply the function to each dataset and store results
analyze_mitml_bal_mcar_50 <- Analyze_mitml_Bal(mitml_bal_mcar_50)
# Convert the data frame to a panel data frame
pdata_unbal <- pdata.frame(unbalanced_panel_data, index = c("ID", "Year"))
# Estimate the fixed effects model
fe_model <- plm(Income ~ Year + Education + Age, data = pdata_unbal, model = "within")
# Estimate the random effects model
re_model <- plm(Income ~ Year + Education + Age, data = pdata_unbal, model = "random")
# Perform the Hausman test to compare the fixed and random effects models
hausman_test <- phtest(fe_model, re_model)
# Print the results of the Hausman test
print(hausman_test)
# Function to impute data for unbalanced panels
Data_Imputation_mitml_Unbal <- function(panel_data) {
# Prepare the data by ungrouping and selecting relevant columns
panel_data <- panel_data %>%
ungroup()
selected_data <- as.data.frame(panel_data[c("ID", "Year", "Education", "Age", "Income")])
# Define the type vector and assign column names
type <- c(0, -2, 2, 2, 1)
names(type) <- colnames(selected_data)
# Impute missing data
imputed_data <- panImpute(selected_data, type = type, n.burn = 1000, n.iter = 100, m = 3)
# Extract imputed datasets
imputed_list <- mitmlComplete(imputed_data, print = "all")
return(imputed_list)
}
# Apply the function to each dataset
mitml_unbal_mcar_50 <- Data_Imputation_mitml_Unbal(unbalanced_panel_data_mcar_50)
# Function to analyze imputed data and extract coefficients for unbalanced panels
Analyze_mitml_Unbal <- function(imputed_list) {
# Step 2: Perform Breusch-Pagan test to check for a panel effect
breusch_pagan_results <- lapply(imputed_list, function(x) {
pdata <- pdata.frame(x, index = c("ID", "Year"))
bp_test <- plmtest(plm(Income ~ Education + Age, data = pdata, model = "pooling"), type = "bp")
return(bp_test$p.value)
})
# Step 3: Based on Breusch-Pagan test, perform the appropriate regression
model_list <- lapply(1:length(imputed_list), function(i) {
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year"))
if (breusch_pagan_results[[i]] > 0.05) {
# Pooled OLS for no panel effect
return(plm(Income ~ Year + Education + Age, data = pdata, model = "pooling"))
} else {
# Hausman test if panel effect exists
random_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
fixed_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
# Perform Hausman test
hausman_test <- phtest(fixed_model, random_model)
if (hausman_test$p.value <= 0.05) {
# Fixed Effect model if correlation exist
print("Fixed Effects")
return(fixed_model)
} else {
# Random Effect model if the correlation does not exists
print("Random Effects")
return(random_model)
}
}
})
# Step 4: Pool the results
pooled_results <- testEstimates(model_list)
# Return the pooled results summary
return(summary(pooled_results))
}
# Apply the analysis function to each set of imputed datasets
analyze_mitml_unbal_mcar_50 <- Analyze_mitml_Unbal(mitml_unbal_mcar_50)
library(Amelia)
# Define the function for panel data conversion and imputation
Data_Imputation_Amelia <- function(data) {
# Convert the data to panel data using plm package
pdata <- pdata.frame(data, index = c("ID", "Year"))
pdata = pdata[c("ID", "Year", "Education", "Age", "Income")]
pdata$Year <- as.numeric(as.character(pdata$Year))
# Perform the imputation using Amelia
amelia_fit <- amelia(
pdata,
m = 3,
ts = "Year",
cs = "ID",
noms = "Education"
)
# Return the fitted Amelia object
return(amelia_fit)
}
# Apply the function to each dataset and store results
amelia_bal_mcar_50 <- Data_Imputation_Amelia(balanced_panel_data_mcar_50)
# Function to perform analysis on imputed data
Analyze_Amelia <- function(data) {
# Step 1: Perform data imputation
amelia_fit <- Data_Imputation_Amelia(data)
# Extract imputed datasets
imputed_list <- amelia_fit$imputations
# Step 2: Perform Breusch-Pagan test to check for a panel effect
breusch_pagan_results <- lapply(imputed_list, function(x) {
pdata <- pdata.frame(x, index = c("ID", "Year"))
bp_test <- plmtest(plm(Income ~ Year + Education + Age, data = pdata, model = "pooling"), type = "bp")
return(bp_test$p.value)
})
# Step 3: Based on Breusch-Pagan test, perform the appropriate regression
model_list <- lapply(1:length(imputed_list), function(i) {
pdata <- pdata.frame(imputed_list[[i]], index = c("ID", "Year"))
if (breusch_pagan_results[[i]] > 0.05) {
# Pooled OLS for no panel effect
return(plm(Income ~ Year + Education + Age, data = pdata, model = "pooling"))
} else {
# Hausman test if panel effect exists
random_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
fixed_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
# Perform Hausman test
hausman_test <- phtest(fixed_model, random_model)
if (hausman_test$p.value <= 0.05) {
# Use Fixed Effect model if correlation exists
print("Fixed Effects")
return(fixed_model)
} else {
# Random Effect model if correlation does not exists
print("Random Effects")
return(random_model)
}
}
})
# Step 4: Pool the results
pooled_results <- testEstimates(model_list)
# Return the pooled results summary
return(summary(pooled_results))
}
# Apply the function to each dataset and store results
analyze_amelia_bal_mcar_50 <- Analyze_Amelia(balanced_panel_data_mcar_50)
library(keras)
library(dplyr)
library(plm)
# Define a function for LSTM-based imputation
Data_Imputation_LSTM <- function(data) {
# Handle missing values: Temporarily fill missing Income values with column mean
temp_data <- data %>%
mutate(Income = ifelse(is.na(Income), mean(Income, na.rm = TRUE), Income))
# Convert 'Education' to numeric using one-hot encoding
encoded_data <- temp_data %>%
mutate(Education = as.factor(Education)) %>%
select(Age, Income, Education)
# One-hot encode the 'Education' column
encoded_data <- as.data.frame(model.matrix(~ Education - 1, data = encoded_data))
# Include other numeric columns (Age and Income)
input_data <- cbind(data$Age, data$Income, encoded_data)
# Convert the data to a 3D array suitable for LSTM
train_array <- array(as.matrix(input_data), dim = c(nrow(input_data), 1, ncol(input_data)))
# Define LSTM model
model <- keras_model_sequential() %>%
layer_lstm(units = 50, input_shape = c(1, ncol(input_data)), return_sequences = FALSE) %>%
layer_dense(units = 1)
# Compile the model
model %>% compile(
loss = "mean_squared_error",
optimizer = optimizer_adam()  # Use the standard Adam optimizer
)
# Fit the model (training)
model %>% fit(
x = train_array,
y = temp_data$Income,  # Target is the Income column
epochs = 50,
batch_size = 32
)
# Predict values for the missing data
predicted_values <- model %>% predict(train_array)
# Replace missing values in the original dataset with predicted values
data$Income[is.na(data$Income)] <- predicted_values[is.na(data$Income)]
# Return the imputed data
return(data)
}
# Apply the function to each dataset and store results
lstm_bal_mcar_50 <- Data_Imputation_LSTM(balanced_panel_data_mcar_50)
# Function to perform analysis on LSTM-imputed data
Analyze_LSTM <- function(data) {
# Step 1: Perform data imputation
imputed_data <- Data_Imputation_LSTM(data)
# Convert to panel data
pdata <- pdata.frame(imputed_data, index = c("ID", "Year"))
# Step 2: Perform Breusch-Pagan test to check for a panel effect
bp_test <- plmtest(plm(Income ~ Year + Education + Age, data = pdata, model = "pooling"), type = "bp")
# Step 3: Based on Breusch-Pagan test, perform the appropriate regression
if (bp_test$p.value > 0.05) {
# No panel effect, proceed with Pooled OLS model
model <- plm(Income ~ Year + Education + Age, data = pdata, model = "pooling")
} else {
# Panel effect exists, proceed to Hausman test
random_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "random")
fixed_model <- plm(Income ~ Year + Education + Age, data = pdata, model = "within")
hausman_test <- phtest(fixed_model, random_model)
if (hausman_test$p.value <= 0.05) {
# Correlation exists, use Fixed Effects Model
model <- fixed_model
} else {
# No correlation, use Random Effects Model
model <- random_model
}
}
# Step 4: Return the model summary
return(summary(model))
}
# Apply the function to each dataset and store results
analyze_lstm_bal_mcar_50 <- Analyze_LSTM(balanced_panel_data_mcar_50)
analyze_lstm_bal_mcar_50
