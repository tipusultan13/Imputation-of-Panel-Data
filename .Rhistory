minPts <- 5
# Identify core points
db <- dbscan(data, eps = eps, minPts = minPts)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = core)) +
geom_point() +
scale_color_manual(values = c("Core" = "blue", "Noise" = "red")) +
ggtitle("Step 2: Core Points and Noise") +
theme_minimal()
# Cluster formation
data$cluster <- as.factor(db$cluster)
ggplot(data, aes(x, y, color = cluster)) +
geom_point() +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
ggtitle("Step 3: Cluster Formation") +
theme_minimal()
# Step-by-step process
plot_dbscan_steps <- function(data, eps, minPts) {
db <- dbscan(data[, 1:2], eps = eps, minPts = minPts)
data$cluster <- as.factor(db$cluster)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = cluster, shape = core)) +
geom_point(size = 3) +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
scale_shape_manual(values = c("Core" = 16, "Noise" = 1)) +
ggtitle("DBSCAN Clustering Step by Step") +
theme_minimal()
}
# Plot the final result
plot_dbscan_steps(data, eps, minPts)
library(ggplot2)
library(animation)
library(dbscan)
# Generate sample data for 3 clusters
set.seed(123)
x <- c(rnorm(50, 0, 2), rnorm(50, 8, 2), rnorm(50, -8, 2))
y <- c(rnorm(50, 0, 2), rnorm(50, 8, 2), rnorm(50, -8, 2))
data <- data.frame(x, y)
# Perform DBSCAN clustering
db <- dbscan(data, eps = 2, minPts = 5)
# Extract core points and their cluster labels
core_points <- data[db$cluster != 0, ]
core_labels <- db$cluster[db$cluster != 0]
# Function to create animation frames
animate_dbscan <- function(data, db, core_points, core_labels) {
frames <- list()
# Initial frame with all core points in blue and noise in gray
initial_plot <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "blue"), size = 3) +
labs(title = "DBSCAN Clustering (Initial)") +
theme_minimal()
frames[[1]] <- initial_plot
# Clusters
cluster_colors <- c("#FF0000", "#0000FF", "#00FF00")  # Red, Blue, Green
unique_labels <- unique(core_labels)
frame_counter <- 2
for (cluster_index in seq_along(unique_labels)) {
cluster_label <- unique_labels[cluster_index]
cluster_points <- data[db$cluster == cluster_label, ]
for (point_index in 1:nrow(cluster_points)) {
current_core <- core_points[core_labels == cluster_label, ][1:point_index, ]
p <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "gray80"), size = 3) +
geom_point(data = cluster_points[1:point_index, ], aes(x, y), color = cluster_colors[cluster_index], size = 5) +
labs(title = paste("DBSCAN Clustering (Frame", frame_counter, ")")) +
theme_minimal()
frames[[frame_counter]] <- p
frame_counter <- frame_counter + 1
}
}
# Final frame showing all clusters in their respective colors
final_plot <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "gray80"), size = 3) +
geom_point(data = core_points, aes(x, y, color = factor(core_labels)), size = 5) +
scale_color_manual(values = cluster_colors) +
labs(title = "DBSCAN Clustering (Final)", color = "Cluster") +
theme_minimal()
frames[[frame_counter]] <- final_plot
return(frames)
}
# Create animation frames
frames <- animate_dbscan(data, db, core_points, core_labels)
# Create animation
ani.options(interval = 0.5)
saveGIF({
for (i in seq_along(frames)) {
print(frames[[i]])
}
}, movie.name = "dbscan_animation.gif", ani.width = 600, ani.height = 600)
library(pan)
?pan
# Set Directory
setwd("/Users/tipusultan/Documents/GitHub/Imputation-of-Panel-Data")
library(dplyr)
library(readxl)
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
RawData
data = RawData[c("id", "year","EF310", "EF44", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "Age", "IndividualIncome")
summary(data)
# 'ID' column
count(data, ID)
# 'Year' column
count(data, Year)
data <- subset(data, Year >= 2013 & Year <= 2023) # Filter the data to keep only rows where the 'Year' is between 2013 and 2023 inclusive
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# MedianIncome
count(data, Age)
summary(data$Age)
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
summary(data$IndividualIncome)
sum(is.na(data)) #Total number of NA values in the data frame
summary(data)
########################
## Balanced Panel
########################
# Ensure the 'Year' column is numeric or integer
data$Year <- as.numeric(data$Year)
# Find IDs that are present in all years between 2013 and 2023
years <- 2013:2023
common_ids <- Reduce(intersect, lapply(years, function(year) {
unique(data$ID[data$Year == year])
}))
# Filter the data to keep only rows with common IDs
BalancedPanel <- data[data$ID %in% common_ids, ]
# Print the final data to check the result
print(BalancedPanel)
# Count the number of unique years each ID appears in
id_year_count <- aggregate(Year ~ ID, data = BalancedPanel,
FUN = function(x) length(unique(x)))
# Check if every ID appears in all the years (2013 to 2023)
is_balanced_panel <- all(id_year_count$Year == length(2013:2023))
if (is_balanced_panel) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Optionally, print the IDs that do not appear in all years
unbalanced_ids <- id_year_count$ID[id_year_count$Year != length(2013:2023)]
if (length(unbalanced_ids) > 0) {
print("IDs that do not appear in all years:")
print(unbalanced_ids)
}
########################
## Unalanced Panel
########################
# The initial data is considered as a unbalanced panel data
UnbalancedPanel <- data
# Count the number of unique years each ID appears in
id_year_count <- aggregate(Year ~ ID, data = UnbalancedPanel,
FUN = function(x) length(unique(x)))
# Check if every ID appears in all the years (2013 to 2023)
is_balanced_panel <- all(id_year_count$Year == length(2013:2023))
if (is_balanced_panel) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Optionally, print the IDs that do not appear in all years
unbalanced_ids <- id_year_count$ID[id_year_count$Year != length(2013:2023)]
if (length(unbalanced_ids) > 0) {
print("IDs that do not appear in all years:")
print(unbalanced_ids)
}
summary(data$Age)
# Set Directory
setwd("/Users/tipusultan/Documents/GitHub/Imputation-of-Panel-Data")
library(dplyr)
library(readxl)
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("id", "year","EF310", "EF44", "inc.ind")]
colnames(data) <- c("ID", "Year", "Education", "Age", "IndividualIncome")
summary(data)
# 'ID' column
count(data, ID)
# 'Year' column
count(data, Year)
data <- subset(data, Year >= 2013 & Year <= 2023) # Filter the data to keep only rows where the 'Year' is between 2013 and 2023 inclusive
# 'Education' column - Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# MedianIncome
count(data, Age)
summary(data$Age)
# 'IndividualIncome' column - Income
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
summary(data$IndividualIncome)
sum(is.na(data)) #Total number of NA values in the data frame
summary(data)
sum(is.na(data)) #Total number of NA values in the data frame
summary(data)
########################
## Balanced Panel
########################
# Ensure the 'Year' column is numeric or integer
data$Year <- as.numeric(data$Year)
# Find IDs that are present in all years between 2013 and 2023
years <- 2013:2023
common_ids <- Reduce(intersect, lapply(years, function(year) {
unique(data$ID[data$Year == year])
}))
# Filter the data to keep only rows with common IDs
balanced_panel_data <- data[data$ID %in% common_ids, ]
# Print the final data to check the result
print(balanced_panel_data)
# Count the number of unique years each ID appears in
id_year_count <- aggregate(Year ~ ID, data = balanced_panel_data,
FUN = function(x) length(unique(x)))
# Check if every ID appears in all the years (2013 to 2023)
is_balanced_panel <- all(id_year_count$Year == length(2013:2023))
if (is_balanced_panel) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Optionally, print the IDs that do not appear in all years
unbalanced_ids <- id_year_count$ID[id_year_count$Year != length(2013:2023)]
if (length(unbalanced_ids) > 0) {
print("IDs that do not appear in all years:")
print(unbalanced_ids)
}
########################
## Unalanced Panel
########################
# The initial data is considered as a unbalanced panel data
unbalanced_panel_data <- data
# Count the number of unique years each ID appears in
id_year_count <- aggregate(Year ~ ID, data = unbalanced_panel_data,
FUN = function(x) length(unique(x)))
# Check if every ID appears in all the years (2013 to 2023)
is_balanced_panel <- all(id_year_count$Year == length(2013:2023))
if (is_balanced_panel) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Optionally, print the IDs that do not appear in all years
unbalanced_ids <- id_year_count$ID[id_year_count$Year != length(2013:2023)]
if (length(unbalanced_ids) > 0) {
print("IDs that do not appear in all years:")
print(unbalanced_ids)
}
p_mis_50 <- 0.50
num_rows <- nrow(balanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_50 <- sample(1:num_rows, p_mis_50 * num_rows, replace = FALSE)
balanced_panel_data_mcar_50 <- balanced_panel_data
balanced_panel_data_mcar_50[mis_simulated_mcar_50, 3] <- NA
summary(balanced_panel_data_mcar_50)
p_mis_30 <- 0.30
num_rows <- nrow(balanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_30 <- sample(1:num_rows, p_mis_30 * num_rows, replace = FALSE)
balanced_panel_data_mcar_30 <- balanced_panel_data
balanced_panel_data_mcar_30[mis_simulated_mcar_30, 3] <- NA
summary(balanced_panel_data_mcar_30)
p_mis_10 <- 0.10
num_rows <- nrow(balanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_10 <- sample(1:num_rows, p_mis_10 * num_rows, replace = FALSE)
balanced_panel_data_mcar_10 <- balanced_panel_data
balanced_panel_data_mcar_10[mis_simulated_mcar_10, 3] <- NA
summary(balanced_panel_data_mcar_10)
p_mis_50 <- 0.50
num_rows <- nrow(balanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_50 <- sample(1:num_rows, p_mis_50 * num_rows, replace = FALSE)
balanced_panel_data_mcar_50 <- balanced_panel_data
balanced_panel_data_mcar_50[mis_simulated_mcar_50, 3] <- NA
summary(balanced_panel_data_mcar_50)
p_mis_50 <- 0.50
num_rows <- nrow(balanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_50 <- sample(1:num_rows, p_mis_50 * num_rows, replace = FALSE)
balanced_panel_data_mcar_50 <- balanced_panel_data
balanced_panel_data_mcar_50[mis_simulated_mcar_50, 5] <- NA
summary(balanced_panel_data_mcar_50)
p_mis_30 <- 0.30
num_rows <- nrow(balanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_30 <- sample(1:num_rows, p_mis_30 * num_rows, replace = FALSE)
balanced_panel_data_mcar_30 <- balanced_panel_data
balanced_panel_data_mcar_30[mis_simulated_mcar_30, 5] <- NA
summary(balanced_panel_data_mcar_30)
p_mis_10 <- 0.10
num_rows <- nrow(balanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_10 <- sample(1:num_rows, p_mis_10 * num_rows, replace = FALSE)
balanced_panel_data_mcar_10 <- balanced_panel_data
balanced_panel_data_mcar_10[mis_simulated_mcar_10, 5] <- NA
summary(balanced_panel_data_mcar_10)
#### 50% ####
balanced_panel_data_mar_50 <- balanced_panel_data
set.seed(123)
p_mis_50 <- 0.5  # 50% missingness
# Model missingness via linear regression model
# Depending on x1, x2, and random error
mis_simulated_mar_50 <- 0.5 + 2 * balanced_panel_data_mar_50$x1 -
0.7 * balanced_panel_data_mar_50$x2 +
rnorm(nrow(balanced_panel_data_mar_50), 0, 3)
#### 50% ####
balanced_panel_data_mar_50 <- balanced_panel_data
set.seed(123)
p_mis_50 <- 0.5  # 50% missingness
# Model missingness via linear regression model
# Depending on Education, Age, and random error
mis_simulated_mar_50 <- 0.5 + 2 * balanced_panel_data_mar_50$Education -
0.7 * balanced_panel_data_mar_50$Age +
rnorm(nrow(balanced_panel_data_mar_50), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_50 <- mis_simulated_mar_50 < quantile(mis_simulated_mar_50, p_mis_50)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_50))
# Set values to NA in y where missingness occurs
balanced_panel_data_mar_50$IndividualIncome[mis_simulated_mar_50] <- NA
# Summary of y after introducing missingness
summary(balanced_panel_data_mar_50)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_50))
# Set values to NA in y where missingness occurs
balanced_panel_data_mar_50$IndividualIncome[mis_simulated_mar_50] <- NA
# Summary of y after introducing missingness
summary(balanced_panel_data_mar_50)
# Model missingness via linear regression model
# Depending on Education, Age, and random error
mis_simulated_mar_30 <- 0.5 + 2 * balanced_panel_data_mar_30$Education -
0.7 * balanced_panel_data_mar_30$Age +
rnorm(nrow(balanced_panel_data_mar_30), 0, 3)
#### 30% ####
balanced_panel_data_mar_30 <- balanced_panel_data
set.seed(123)
p_mis_50 <- 0.3  # 30% missingness
# Model missingness via linear regression model
# Depending on Education, Age, and random error
mis_simulated_mar_30 <- 0.5 + 2 * balanced_panel_data_mar_30$Education -
0.7 * balanced_panel_data_mar_30$Age +
rnorm(nrow(balanced_panel_data_mar_30), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_30 <- mis_simulated_mar_30 < quantile(mis_simulated_mar_30, p_mis_30)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_30))
# Set values to NA in y where missingness occurs
balanced_panel_data_mar_30$IndividualIncome[mis_simulated_mar_30] <- NA
# Summary of y after introducing missingness
summary(balanced_panel_data_mar_30)
balanced_panel_data_mar_10 <- balanced_panel_data
set.seed(123)
p_mis_50 <- 0.1  # 10% missingness
# Model missingness via linear regression model
# Depending on Education, Age, and random error
mis_simulated_mar_10 <- 0.5 + 2 * balanced_panel_data_mar_10$Education -
0.7 * balanced_panel_data_mar_10$Age +
rnorm(nrow(balanced_panel_data_mar_10), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_10 <- mis_simulated_mar_10 < quantile(mis_simulated_mar_10, p_mis_10)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_10))
# Set values to NA in y where missingness occurs
balanced_panel_data_mar_10$IndividualIncome[mis_simulated_mar_10] <- NA
# Summary of y after introducing missingness
summary(balanced_panel_data_mar_10)
p_mis_50 <- .50
balanced_panel_data_mnar_50 <- balanced_panel_data
# model missingness by logistic regression (probit):
# the missing of a value now also depends on counts itself
mis_simulated_mnar_50 <-0.5 + 1 * balanced_panel_data_mnar_50$Education -
0.7 * balanced_panel_data_mnar_50$Age -
5 * balanced_panel_data_mnar_50$IndividualIncome + rnorm(nrow(balanced_panel_data), 0, 3)
mis_simulated_mnar_50 <- mis_simulated_mnar_50 < quantile(mis_simulated_mnar_50, p_mis_50)
balanced_panel_data_mnar_50$IndividualIncome[mis_simulated_mnar_50] <- NA
summary(balanced_panel_data_mnar_50)
p_mis_30 <- .30
balanced_panel_data_mnar_30 <- balanced_panel_data
# model missingness by logistic regression (probit):
# the missing of a value now also depends on counts itself
mis_simulated_mnar_30 <-0.5 + 1 * balanced_panel_data_mnar_30$Education -
0.7 * balanced_panel_data_mnar_30$Age -
5 * balanced_panel_data_mnar_30$IndividualIncome + rnorm(nrow(balanced_panel_data), 0, 3)
mis_simulated_mnar_30 <- mis_simulated_mnar_30 < quantile(mis_simulated_mnar_30, p_mis_30)
balanced_panel_data_mnar_30$IndividualIncome[mis_simulated_mnar_30] <- NA
summary(balanced_panel_data_mnar_30)
p_mis_10 <- .10
balanced_panel_data_mnar_10 <- balanced_panel_data
# model missingness by logistic regression (probit):
# the missing of a value now also depends on counts itself
mis_simulated_mnar_10 <-0.5 + 1 * balanced_panel_data_mnar_10$Education -
0.7 * balanced_panel_data_mnar_10$Age -
5 * balanced_panel_data_mnar_10$IndividualIncome + rnorm(nrow(balanced_panel_data), 0, 3)
mis_simulated_mnar_10 <- mis_simulated_mnar_10 < quantile(mis_simulated_mnar_10, p_mis_10)
balanced_panel_data_mnar_10$IndividualIncome[mis_simulated_mnar_10] <- NA
summary(balanced_panel_data_mnar_10)
p_mis_50 <- 0.50
num_rows <- nrow(unbalanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_50 <- sample(1:num_rows, p_mis_50 * num_rows, replace = FALSE)
unbalanced_panel_data_mcar_50 <- unbalanced_panel_data
unbalanced_panel_data_mcar_50[mis_simulated_mcar_50, 3] <- NA
summary(unbalanced_panel_data_mcar_50)
p_mis_50 <- 0.50
num_rows <- nrow(unbalanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_50 <- sample(1:num_rows, p_mis_50 * num_rows, replace = FALSE)
unbalanced_panel_data_mcar_50 <- unbalanced_panel_data
unbalanced_panel_data_mcar_50[mis_simulated_mcar_50, 5] <- NA
summary(unbalanced_panel_data_mcar_50)
p_mis_30 <- 0.30
num_rows <- nrow(unbalanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_30 <- sample(1:num_rows, p_mis_30 * num_rows, replace = FALSE)
unbalanced_panel_data_mcar_30 <- unbalanced_panel_data
unbalanced_panel_data_mcar_30[mis_simulated_mcar_30, 5] <- NA
summary(unbalanced_panel_data_mcar_30)
p_mis_10 <- 0.10
num_rows <- nrow(unbalanced_panel_data)  # Get the number of rows in balanced_panel_data
mis_simulated_mcar_10 <- sample(1:num_rows, p_mis_10 * num_rows, replace = FALSE)
unbalanced_panel_data_mcar_10 <- unbalanced_panel_data
unbalanced_panel_data_mcar_10[mis_simulated_mcar_10, 5] <- NA
summary(unbalanced_panel_data_mcar_10)
#### 50% ####
unbalanced_panel_data_mar_50 <- unbalanced_panel_data
set.seed(123)
p_mis_50 <- 0.5  # 50% missingness
# Model missingness via linear regression model
# Depending on x1, x2, and random error
mis_simulated_mar_50 <- 0.5 + 2 * unbalanced_panel_data_mar_50$Education -
0.7 * unbalanced_panel_data_mar_50$Age +
rnorm(nrow(unbalanced_panel_data_mar_50), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_50 <- mis_simulated_mar_50 < quantile(mis_simulated_mar_50, p_mis_50)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_50))
# Set values to NA in y where missingness occurs
unbalanced_panel_data_mar_50$IndividualIncome[mis_simulated_mar_50] <- NA
# Summary of y after introducing missingness
summary(unbalanced_panel_data_mar_50)
#### 30% ####
unbalanced_panel_data_mar_30 <- unbalanced_panel_data
set.seed(123)
p_mis_50 <- 0.3  # 30% missingness
# Model missingness via linear regression model
# Depending on Education, Age, and random error
mis_simulated_mar_30 <- 0.5 + 2 * unbalanced_panel_data_mar_30$Education -
0.7 * unbalanced_panel_data_mar_30$Age +
rnorm(nrow(unbalanced_panel_data_mar_30), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_30 <- mis_simulated_mar_30 < quantile(mis_simulated_mar_30, p_mis_30)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_30))
# Set values to NA in y where missingness occurs
unbalanced_panel_data_mar_30$IndividualIncome[mis_simulated_mar_30] <- NA
# Summary of y after introducing missingness
summary(unbalanced_panel_data_mar_30)
unbalanced_panel_data_mar_10 <- unbalanced_panel_data
set.seed(123)
p_mis_50 <- 0.1  # 10% missingness
# Model missingness via linear regression model
# Depending on Education, Age, and random error
mis_simulated_mar_10 <- 0.5 + 2 * unbalanced_panel_data_mar_10$Education -
0.7 * unbalanced_panel_data_mar_10$Age +
rnorm(nrow(unbalanced_panel_data_mar_10), 0, 3)
# All below the 50% quantile are set to missing
mis_simulated_mar_10 <- mis_simulated_mar_10 < quantile(mis_simulated_mar_10, p_mis_10)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_10))
# Set values to NA in y where missingness occurs
unbalanced_panel_data_mar_10$IndividualIncome[mis_simulated_mar_10] <- NA
# Summary of y after introducing missingness
summary(unbalanced_panel_data_mar_10)
# Proportion of missing data
mean(as.numeric(mis_simulated_mar_10))
# Summary of IndividualIncome after introducing missingness
summary(unbalanced_panel_data_mar_50)
p_mis_50 <- .50
unbalanced_panel_data_mnar_50 <- unbalanced_panel_data
# model missingness by logistic regression (probit):
# the missing of a value now also depends on IndividualIncome itself
mis_simulated_mnar_50 <-0.5 + 1 * unbalanced_panel_data_mnar_50$Education -
0.7 * unbalanced_panel_data_mnar_50$Age -
5 * unbalanced_panel_data_mnar_50$IndividualIncome + rnorm(nrow(unbalanced_panel_data), 0, 3)
mis_simulated_mnar_50 <- mis_simulated_mnar_50 < quantile(mis_simulated_mnar_50, p_mis_50)
unbalanced_panel_data_mnar_50$IndividualIncome[mis_simulated_mnar_50] <- NA
summary(unbalanced_panel_data_mnar_50)
p_mis_50 <- .50
unbalanced_panel_data_mnar_50 <- unbalanced_panel_data
# model missingness by logistic regression (probit):
# the missing of a value now also depends on IndividualIncome itself
mis_simulated_mnar_50 <-0.5 + 1 * unbalanced_panel_data_mnar_50$Education -
0.7 * unbalanced_panel_data_mnar_50$Age -
5 * unbalanced_panel_data_mnar_50$IndividualIncome + rnorm(nrow(unbalanced_panel_data), 0, 3)
mis_simulated_mnar_50 <- mis_simulated_mnar_50 < quantile(mis_simulated_mnar_50, p_mis_50)
unbalanced_panel_data_mnar_50$IndividualIncome[mis_simulated_mnar_50] <- NA
summary(unbalanced_panel_data_mnar_50)
p_mis_30 <- .30
unbalanced_panel_data_mnar_30 <- unbalanced_panel_data
# model missingness by logistic regression (probit):
# the missing of a value now also depends on IndividualIncome itself
mis_simulated_mnar_30 <-0.5 + 1 * unbalanced_panel_data_mnar_30$Education -
0.7 * unbalanced_panel_data_mnar_30$Age -
5 * unbalanced_panel_data_mnar_30$IndividualIncome + rnorm(nrow(unbalanced_panel_data), 0, 3)
mis_simulated_mnar_30 <- mis_simulated_mnar_30 < quantile(mis_simulated_mnar_30, p_mis_30)
unbalanced_panel_data_mnar_30$IndividualIncome[mis_simulated_mnar_30] <- NA
summary(unbalanced_panel_data_mnar_30)
p_mis_10 <- .10
unbalanced_panel_data_mnar_10 <- unbalanced_panel_data
# model missingness by logistic regression (probit):
# the missing of a value now also depends on IndividualIncome itself
mis_simulated_mnar_10 <-0.5 + 1 * unbalanced_panel_data_mnar_10$Education -
0.7 * unbalanced_panel_data_mnar_10$Age -
5 * unbalanced_panel_data_mnar_10$IndividualIncome + rnorm(nrow(unbalanced_panel_data), 0, 3)
mis_simulated_mnar_10 <- mis_simulated_mnar_10 < quantile(mis_simulated_mnar_10, p_mis_10)
unbalanced_panel_data_mnar_10$IndividualIncome[mis_simulated_mnar_10] <- NA
summary(unbalanced_panel_data_mnar_10)
View(unbalanced_panel_data_mnar_10)
