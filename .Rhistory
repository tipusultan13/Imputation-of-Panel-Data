IndividualIncomeLogHist
DataTempAge <- data[data$Age >= 18 & data$Age <= 67, ]
AFilteredIncomeLogHist <- ggplot(DataTempAge, aes(x = LogIndividualIncome)) +
geom_histogram(binwidth = .10) +
labs(title = "Logged Income (Age: 18-67)", x = "Income", y = "Frequency")+
theme_minimal()
AFilteredIncomeLogHist
DataTempIncome <- data[data$IndividualIncome != 0, ]
IFilteredIncomeLogHist <- ggplot(DataTempIncome, aes(x = LogIndividualIncome)) +
geom_histogram(binwidth = .10) +
labs(title = "Logged Income (Without 0)", x = "Income", y = "Frequency")+
theme_minimal()
IFilteredIncomeLogHist
grid.arrange(IndividualIncomeHist, IndividualIncomeLogHist, AFilteredIncomeLogHist, IFilteredIncomeLogHist, ncol = 2)
sum(is.na(data)) #Total number of missing values
colnames(data)[colnames(data) == "LogIndividualIncome"] <- "Income"
data <- data[c("ID", "Year", "Education", "Age", "Income", "MaritalStatus", "EmploymentType", "EmploymentHours")]
summary(data)
#########################
## Balanced Panel
########################
data$Year <- as.numeric(data$Year) # Convert Year column to make the calculation easy
# Find IDs that are present in all years between 2013 and 2023
years <- 2013:2023
CommonIDS <- Reduce(intersect, lapply(years, function(year) {
unique(data$ID[data$Year == year])
}))
PanelData <- data[data$ID %in% CommonIDS, ] # Filter the data to keep only rows with common IDs
# Count the occurrence of each ID
IDCounts <- PanelData %>%
count(ID)
# Extract IDs with exactly 11 occurrences
ids_with_11_occurrences <- IDCounts %>%
filter(n == 11) %>%
pull(ID)
# Filter the original dataset to include only rows with these IDs
balanced_panel_data <- PanelData %>%
filter(ID %in% ids_with_11_occurrences)
# Count the number of unique years each ID appears in
IDYearCounts <- aggregate(Year ~ ID, data = balanced_panel_data,
FUN = function(x) length(unique(x)))
is_balanced_panel <- all(IDYearCounts$Year == length(2013:2023)) # Check if every ID appears in all the years (2013 to 2023)
if (is_balanced_panel) {
print("Balanced Panel Data")
} else {
print("Unbalanced Panel Data")
}
# Print the IDs that do not appear in all years (optional task)
UnbalancedIDS <- IDYearCounts$ID[IDYearCounts$Year != length(2013:2023)]
if (length(UnbalancedIDS) > 0) {
print("IDs that are not present in all years:")
print(UnbalancedIDS)
}
# Count the occurrence of each ID
IDCounts <- balanced_panel_data %>%
count(ID)
# Filter IDs that appear more than 11 times
more_than_11 <- IDCounts %>%
filter(n > 11)
num_more_than_11 <- nrow(more_than_11)
# Filter IDs that appear less than 11 times
less_than_11 <- IDCounts %>%
filter(n < 11)
num_less_than_11 <- nrow(less_than_11)
print(paste("Number of IDs appearing more than 11 times:", num_more_than_11))
print(paste("Number of IDs appearing less than 11 times:", num_less_than_11))
count(balanced_panel_data, Year)
summary(balanced_panel_data)
########################
## Unalanced Panel
########################
SampleData <- data.frame()
# Loop through each year to ensure 50483 unique ID-Year combinations
for (yr in unique(data$Year)) {
# Filter the data for the current year
YearData <- data %>% filter(Year == yr)
# Sample 50483 unique ID-Year combinations for this year
SampleTemp <- YearData %>%
distinct(ID, Year, .keep_all = TRUE) %>%
slice_sample(n = 50483)
# Append the sampled data to the main data frame
SampleData <- bind_rows(SampleData, SampleTemp)
}
unbalanced_panel_data <- SampleData
# Count the number of unique years each ID appears in
IDYearCounts <- aggregate(Year ~ ID, data = unbalanced_panel_data,
FUN = function(x) length(unique(x)))
is_balanced_panel <- all(IDYearCounts$Year == length(2013:2023)) # Check if every ID appears in all the years (2013 to 2023)
if (is_balanced_panel) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Print the IDs that do not appear in all years
UnbalancedIDS <- IDYearCounts$ID[IDYearCounts$Year != length(2013:2023)]
if (length(UnbalancedIDS) > 0) {
print("IDs that do not appear in all years:")
print(UnbalancedIDS)
}
print(unbalanced_panel_data[duplicated(unbalanced_panel_data), ]) # Check for duplicate rows in the data
count(unbalanced_panel_data, Year)
summary(unbalanced_panel_data)
df$EmploymentHours <- as.factor(df$EmploymentHours)
return(df)
## Format Vriable to Their Originl Format
convert_to_factors <- function(df) {
df$ID <- as.factor(df$ID)
df$Year <- as.factor(df$Year)
df$Education <- as.factor(df$Education)
df$MaritalStatus <- as.factor(df$MaritalStatus)
df$EmploymentType <- as.factor(df$EmploymentType)
df$EmploymentHours <- as.factor(df$EmploymentHours)
return(df)
}
# Apply the function to each dataset
balanced_panel_data <- convert_to_factors(balanced_panel_data)
unbalanced_panel_data <- convert_to_factors(unbalanced_panel_data)
balanced_panel_data
ModelSelection <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
# Breusch-Pagan test
BPTest <- plmtest(plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "pooling"), type = "bp")
if (BPTest$p.value > 0.05) {
cat("P-Value:", BPTest$p.value, "\n")
cat("Model: Pooled OLS")
} else {
# Hausman test to check the type of panel effect
RandomEffectModel <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "random")
FixedEffectModel <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
HausmanTest <- phtest(FixedEffectModel, RandomEffectModel)
if (HausmanTest$p.value <= 0.05) {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Fixed Effect")
} else {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Random Effect")
}
}
}
ModelSelection(balanced_panel_data)
ModelSelection(unbalanced_panel_data)
ModelSelection(unbalanced_panel_data)
ModelSelection <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
# Breusch-Pagan test
BPTest <- plmtest(plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "pooling"), type = "bp")
if (BPTest$p.value > 0.05) {
cat("P-Value:", BPTest$p.value, "\n")
cat("Model: Pooled OLS")
} else {
# Hausman test to check the type of panel effect
RandomEffectModel <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "random")
FixedEffectModel <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
HausmanTest <- phtest(FixedEffectModel, RandomEffectModel)
if (HausmanTest$p.value <= 0.05) {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Fixed Effect")
} else {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Random Effect")
}
}
}
ModelSelection(balanced_panel_data)
ModelSelection(unbalanced_panel_data)
unbalanced_panel_data
pdata <- pdata.frame(unbalanced_panel_data, index = c("ID", "Year")) # Converting into the panel format
pdata
ModelSelection <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
# Breusch-Pagan test
BPTest <- plmtest(plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "pooling"), type = "bp")
if (BPTest$p.value > 0.05) {
cat("P-Value:", BPTest$p.value, "\n")
cat("Model: Pooled OLS")
} else {
# Hausman test to check the type of panel effect
RandomEffectModel <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "random")
FixedEffectModel <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
HausmanTest <- phtest(FixedEffectModel, RandomEffectModel)
if (HausmanTest$p.value <= 0.05) {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Fixed Effect")
} else {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Random Effect")
}
}
}
ModelSelection(balanced_panel_data)
ModelSelection(unbalanced_panel_data)
CoefficientsExtraction <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
#pdata <- pdata[c("ID", "Year", "Education", "Age", "Income")]
#####
model <- plm(Income ~ Year + Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
####
Coefficients <- coef(model) # Coefficients extraction
Coefficients <- as.data.frame(Coefficients)
return(Coefficients)
}
balanced_panel_data_coef <- CoefficientsExtraction(balanced_panel_data)
balanced_panel_data_coef
CoefficientsExtraction <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
#pdata <- pdata[c("ID", "Year", "Education", "Age", "Income")]
#####
model <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
####
Coefficients <- coef(model) # Coefficients extraction
Coefficients <- as.data.frame(Coefficients)
return(Coefficients)
}
balanced_panel_data_coef <- CoefficientsExtraction(balanced_panel_data)
unbalanced_panel_data_coef <- CoefficientsExtraction(unbalanced_panel_data)
balanced_panel_data_coef
ModelSelection <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
# Breusch-Pagan test
BPTest <- plmtest(plm(Income ~ Year + Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "pooling"), type = "bp")
if (BPTest$p.value > 0.05) {
cat("P-Value:", BPTest$p.value, "\n")
cat("Model: Pooled OLS")
} else {
# Hausman test to check the type of panel effect
RandomEffectModel <- plm(Income ~ Year + Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "random")
FixedEffectModel <- plm(Income ~ Year + Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
HausmanTest <- phtest(FixedEffectModel, RandomEffectModel)
if (HausmanTest$p.value <= 0.05) {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Fixed Effect")
} else {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Random Effect")
}
}
}
ModelSelection(balanced_panel_data)
ModelSelection(unbalanced_panel_data)
###################################
## Tipu Sultan
###################################
# Set Directory
setwd("/Users/tipusultan/Documents/GitHub/Imputation-of-Panel-Data")
########################
## Data
########################
library(dplyr)
library(readxl)
library(ggplot2)
library(gridExtra)
library(VIM)
library(mice)
library(broom)
library(mitml)
library(plm)
library(lmtest)
library(Amelia)
library(keras)
library(plm)
# Load and clean the data
RawData <- readRDS("population.RDS")
RawData = data.frame(RawData)
data = RawData[c("PID", "year","EF310", "EF44", "inc.ind", "erwerbstyp", "EF49", "vollzeit")]
colnames(data) <- c("ID", "Year", "Education", "Age", "IndividualIncome", "EmploymentType", "MaritalStatus", "EmploymentHours" )
summary(data)
# 'ID'
count(data, ID)
# 'Year'
count(data, Year)
data <- subset(data, Year >= 2013 & Year <= 2023) # Keeping the data from 2013 to 2023
# 'Education': Highest general school degree
count(data, Education)
data$Education[is.na(data$Education)] <- 7
# Age
count(data, Age)
summary(data$Age)
# Density curve for Age
AgeDist <- ggplot(data, aes(x = Age)) +
geom_density() +
labs(title = "Density Curve of Age", x = "Age", y = "Density") +
theme_minimal()
AgeDist
# EmploymentType
count(data, EmploymentType)
summary(data$EmploymentType)
# MaritalStatus
count(data, MaritalStatus)
summary(data$MaritalStatus)
# EmploymentHours
count(data, EmploymentHours)
data$EmploymentHours[is.na(data$EmploymentHours)] <- 2
summary(data$EmploymentHours)
# Cleaning income column
summary(data$IndividualIncome)
count(data, IndividualIncome)
data$IndividualIncome[is.na(data$IndividualIncome)] <- 0
summary(data$IndividualIncome)
# Histogram for Individual Income
IndividualIncomeHist <- ggplot(data, aes(x = IndividualIncome)) +
geom_histogram(binwidth = 1000) +
labs(title = "Income", x = "Income", y = "Frequency") +
theme_minimal()
IndividualIncomeHist
# Apply log transformation to IndividualIncome (adding 1 to avoid log(0))
data$LogIndividualIncome <- log(data$IndividualIncome + 1)
IndividualIncomeLogHist <- ggplot(data, aes(x = LogIndividualIncome)) +
geom_histogram(binwidth = .10) +
labs(title = "Logged Income", x = "Income", y = "Frequency")+
theme_minimal()
IndividualIncomeLogHist
DataTempAge <- data[data$Age >= 18 & data$Age <= 67, ]
AFilteredIncomeLogHist <- ggplot(DataTempAge, aes(x = LogIndividualIncome)) +
geom_histogram(binwidth = .10) +
labs(title = "Logged Income (Age: 18-67)", x = "Income", y = "Frequency")+
theme_minimal()
AFilteredIncomeLogHist
DataTempIncome <- data[data$IndividualIncome != 0, ]
IFilteredIncomeLogHist <- ggplot(DataTempIncome, aes(x = LogIndividualIncome)) +
geom_histogram(binwidth = .10) +
labs(title = "Logged Income (Without 0)", x = "Income", y = "Frequency")+
theme_minimal()
IFilteredIncomeLogHist
grid.arrange(IndividualIncomeHist, IndividualIncomeLogHist, AFilteredIncomeLogHist, IFilteredIncomeLogHist, ncol = 2)
sum(is.na(data)) #Total number of missing values
colnames(data)[colnames(data) == "LogIndividualIncome"] <- "Income"
data <- data[c("ID", "Year", "Education", "Age", "Income", "MaritalStatus", "EmploymentType", "EmploymentHours")]
summary(data)
#########################
## Balanced Panel
########################
data$Year <- as.numeric(data$Year) # Convert Year column to make the calculation easy
# Find IDs that are present in all years between 2013 and 2023
years <- 2013:2023
CommonIDS <- Reduce(intersect, lapply(years, function(year) {
unique(data$ID[data$Year == year])
}))
PanelData <- data[data$ID %in% CommonIDS, ] # Filter the data to keep only rows with common IDs
# Count the occurrence of each ID
IDCounts <- PanelData %>%
count(ID)
# Extract IDs with exactly 11 occurrences
ids_with_11_occurrences <- IDCounts %>%
filter(n == 11) %>%
pull(ID)
# Filter the original dataset to include only rows with these IDs
balanced_panel_data <- PanelData %>%
filter(ID %in% ids_with_11_occurrences)
# Count the number of unique years each ID appears in
IDYearCounts <- aggregate(Year ~ ID, data = balanced_panel_data,
FUN = function(x) length(unique(x)))
is_balanced_panel <- all(IDYearCounts$Year == length(2013:2023)) # Check if every ID appears in all the years (2013 to 2023)
if (is_balanced_panel) {
print("Balanced Panel Data")
} else {
print("Unbalanced Panel Data")
}
# Print the IDs that do not appear in all years (optional task)
UnbalancedIDS <- IDYearCounts$ID[IDYearCounts$Year != length(2013:2023)]
if (length(UnbalancedIDS) > 0) {
print("IDs that are not present in all years:")
print(UnbalancedIDS)
}
# Count the occurrence of each ID
IDCounts <- balanced_panel_data %>%
count(ID)
# Filter IDs that appear more than 11 times
more_than_11 <- IDCounts %>%
filter(n > 11)
num_more_than_11 <- nrow(more_than_11)
# Filter IDs that appear less than 11 times
less_than_11 <- IDCounts %>%
filter(n < 11)
num_less_than_11 <- nrow(less_than_11)
print(paste("Number of IDs appearing more than 11 times:", num_more_than_11))
print(paste("Number of IDs appearing less than 11 times:", num_less_than_11))
count(balanced_panel_data, Year)
summary(balanced_panel_data)
########################
## Unalanced Panel
########################
SampleData <- data.frame()
# Loop through each year to ensure 50483 unique ID-Year combinations
for (yr in unique(data$Year)) {
# Filter the data for the current year
YearData <- data %>% filter(Year == yr)
# Sample 50483 unique ID-Year combinations for this year
SampleTemp <- YearData %>%
distinct(ID, Year, .keep_all = TRUE) %>%
slice_sample(n = 50483)
# Append the sampled data to the main data frame
SampleData <- bind_rows(SampleData, SampleTemp)
}
unbalanced_panel_data <- SampleData
# Count the number of unique years each ID appears in
IDYearCounts <- aggregate(Year ~ ID, data = unbalanced_panel_data,
FUN = function(x) length(unique(x)))
is_balanced_panel <- all(IDYearCounts$Year == length(2013:2023)) # Check if every ID appears in all the years (2013 to 2023)
if (is_balanced_panel) {
print("The data is a balanced panel.")
} else {
print("The data is not a balanced panel.")
}
# Print the IDs that do not appear in all years
UnbalancedIDS <- IDYearCounts$ID[IDYearCounts$Year != length(2013:2023)]
if (length(UnbalancedIDS) > 0) {
print("IDs that do not appear in all years:")
print(UnbalancedIDS)
}
print(unbalanced_panel_data[duplicated(unbalanced_panel_data), ]) # Check for duplicate rows in the data
count(unbalanced_panel_data, Year)
summary(unbalanced_panel_data)
# Apply the function to each dataset
balanced_panel_data <- convert_to_factors(balanced_panel_data)
unbalanced_panel_data <- convert_to_factors(unbalanced_panel_data)
## Format Vriable to Their Originl Format
convert_to_factors <- function(df) {
df$ID <- as.factor(df$ID)
df$Year <- as.factor(df$Year)
df$Education <- as.factor(df$Education)
df$MaritalStatus <- as.factor(df$MaritalStatus)
df$EmploymentType <- as.factor(df$EmploymentType)
df$EmploymentHours <- as.factor(df$EmploymentHours)
return(df)
}
# Apply the function to each dataset
balanced_panel_data <- convert_to_factors(balanced_panel_data)
unbalanced_panel_data <- convert_to_factors(unbalanced_panel_data)
unbalanced_panel_data
ModelSelection <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
# Breusch-Pagan test
BPTest <- plmtest(plm(Income ~ Year + Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "pooling"), type = "bp")
if (BPTest$p.value > 0.05) {
cat("P-Value:", BPTest$p.value, "\n")
cat("Model: Pooled OLS")
} else {
# Hausman test to check the type of panel effect
RandomEffectModel <- plm(Income ~ Year + Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "random")
FixedEffectModel <- plm(Income ~ Year + Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
HausmanTest <- phtest(FixedEffectModel, RandomEffectModel)
if (HausmanTest$p.value <= 0.05) {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Fixed Effect")
} else {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Random Effect")
}
}
}
ModelSelection(balanced_panel_data)
ModelSelection(unbalanced_panel_data)
ModelSelection <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
# Breusch-Pagan test
BPTest <- plmtest(plm(Income ~ Year + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "pooling"), type = "bp")
if (BPTest$p.value > 0.05) {
cat("P-Value:", BPTest$p.value, "\n")
cat("Model: Pooled OLS")
} else {
# Hausman test to check the type of panel effect
RandomEffectModel <- plm(Income ~ Year + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "random")
FixedEffectModel <- plm(Income ~ Year + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
HausmanTest <- phtest(FixedEffectModel, RandomEffectModel)
if (HausmanTest$p.value <= 0.05) {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Fixed Effect")
} else {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Random Effect")
}
}
}
ModelSelection(balanced_panel_data)
ModelSelection(unbalanced_panel_data)
ModelSelection <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
# Breusch-Pagan test
BPTest <- plmtest(plm(Income ~ Year + Age + MaritalStatus + EmploymentType, data = pdata, model = "pooling"), type = "bp")
if (BPTest$p.value > 0.05) {
cat("P-Value:", BPTest$p.value, "\n")
cat("Model: Pooled OLS")
} else {
# Hausman test to check the type of panel effect
RandomEffectModel <- plm(Income ~ Year + Age + MaritalStatus + EmploymentType, data = pdata, model = "random")
FixedEffectModel <- plm(Income ~ Year + Age + MaritalStatus + EmploymentType, data = pdata, model = "within")
HausmanTest <- phtest(FixedEffectModel, RandomEffectModel)
if (HausmanTest$p.value <= 0.05) {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Fixed Effect")
} else {
cat("P-Value:", HausmanTest$p.value, "\n")
cat("Model: Random Effect")
}
}
}
ModelSelection(balanced_panel_data)
ModelSelection(unbalanced_panel_data)
CoefficientsExtraction <- function(data) {
pdata <- pdata.frame(data, index = c("ID", "Year")) # Converting into the panel format
#pdata <- pdata[c("ID", "Year", "Education", "Age", "Income")]
#####
model <- plm(Income ~ Education + Age + MaritalStatus + EmploymentType + EmploymentHours, data = pdata, model = "within")
####
Coefficients <- coef(model) # Coefficients extraction
Coefficients <- as.data.frame(Coefficients)
return(Coefficients)
}
balanced_panel_data_coef <- CoefficientsExtraction(balanced_panel_data)
unbalanced_panel_data_coef <- CoefficientsExtraction(unbalanced_panel_data)
balanced_panel_data_coef
unbalanced_panel_data_coef
